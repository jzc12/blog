import{o,c as i,a as r}from"./index-9a8f3e9c.js";const s="/blog/assets/scrum-framework-468ddcf3.png",p="/blog/assets/P-backlog-9b11ee8b.png",n="/blog/assets/estimate-87498f10.png",e="/blog/assets/燃尽图-4d0fe52f.png",g="/blog/assets/燃尽图2-733d1973.png",u="/blog/assets/change_cost-d48ea771.png",c="/blog/assets/XP_cost-133ffc66.png",h="/blog/assets/coding-4991024c.png",b="/blog/assets/yagni-b4288a5a.png",a="/blog/assets/kanban1-b07c5923.png",k="/blog/assets/dora1-b1bef9ff.png",q="/blog/assets/dora2-9db45b29.png",d="/blog/assets/dora3-60360219.png",m="/blog/assets/dora4-714d02fd.png",S="/blog/assets/it_dev-ee32a5c6.png",D="/blog/assets/agile-34143c29.png",C="/blog/assets/agile2-2cadbcf6.png",f={class:"markdown-body"},O="2025-06-10T00:00:00.000Z",P="2025-06-16T00:00:00.000Z",T="2025spring",A="软件质量管理复习",K={__name:"软件质量管理_1",setup(I,{expose:l}){return l({frontmatter:{date:"2025-06-10T00:00:00.000Z",updated:"2025-06-16T00:00:00.000Z",category:"2025spring",summary:"软件质量管理复习"}}),(y,t)=>(o(),i("div",f,t[0]||(t[0]=[r('<h2>Scrum</h2><h3>1.结构</h3><p><img src="'+s+'" alt="scrum-framework"></p><h3>2. “33355”</h3><ul><li>三大支柱：</li></ul><blockquote><p>透明：过程与工作成果对团队和利益相关者可见</p><p>检视：定期审查进展，识别偏差（通过5大事件实现</p><p>适应：根据检视结果进行调整、优化过程和产品方向</p></blockquote><ul><li>五个价值：</li></ul><blockquote><p>承诺</p><p>专注</p><p>开放</p><p>尊重</p><p>勇气</p></blockquote><ul><li>三个角色：</li></ul><blockquote><p>PO：负责最大化产品价值和开发团队的工作价值，管理产品Backlog</p><p>Scrum Master:按照Scrum 指南的规则建立Scrum ，服务Scrum Team、PO、组织;确保框架实施，移除障碍</p><p>开发人员:跨职能开发，交付可用增量</p></blockquote><ul><li>三个工件：</li></ul><blockquote><p>产品Backlog、Sprint Backlog、增量</p></blockquote><ul><li>五个事件</li></ul><blockquote><p>Sprint :固定周期（≤1个月），不可变更目标与质</p><p>Sprint 每日计划</p><p>每日Scrum 会议: 15分钟每日站会，调整当日计划</p><p>Sprint 评审会议: 展示增量，调整Backlog</p><p>Sprint 回顾会议: 改进流程与效能</p></blockquote><h3>3.需求——用户故事模板</h3><blockquote><p>作为 &lt; &gt; ——用户画像</p><p>我想 &lt; &gt; ——预期功能</p><p>从而 &lt; &gt; ——为什么用户想要这个功能</p></blockquote><h3>4.Ron Jeffries 的 3C 原则</h3><blockquote><p>卡片：在一堆卡片上写下期望的软件特性</p><p>交谈：聚在一起对要开发的软件进行深入讨论</p><p>确认：对完工条件进行确认</p></blockquote><ul><li>DOD （完成的定义） ——Definition of Done</li><li>BDD (行为驱动开发) ——Behavior-Driven Development <ul><li>核心思想是通过定义软件的行为来驱动开发过程</li><li>重点是增强团队对需求的理解，并确保开发的软件满足业务目标</li><li>强调在开发开始之前，用自然语言描述软件应如何行为</li></ul></li></ul><h3>5. 用户故事 INVEST原则</h3><blockquote><p>独立性</p><p>可协商性</p><p>有价值</p><p>可以估算性</p><p>短小</p><p>可测试性</p><p>每个用户故事都有应该像标准的快递箱——独立封装、地址清晰、体积适中、明确、可追踪、允许改派等</p></blockquote><h3>6. 用户故事SMART原则</h3><blockquote><p>S——Specific(具体)</p><p>M——Measurable(可衡量)：用户故事的结果必须能用明确的指标或验收标准验证</p><p>A——Achievable(可实现)</p><p>R——Relevant(相关性)：用户故事与当前项目或者用户需求相关</p><p>T——Time-bound(有时限)：明确截至时间或者优先级</p></blockquote><h3>7.产品Backlog</h3><ul><li>产品 Backlog 是Scrum 的核心，按照重要性排序的需求或者故事的分列表</li></ul><img src="'+p+'" alt="P-backlog" style="zoom:75%;"><h3>8.Product Backlog（动态需求池）</h3><blockquote><p>是一份涌现的和有序的清单，它列出了改进产品所需的内容。它是 Scrum Team 所承担工作的唯一来源。</p></blockquote><h3>9.用户故事地图</h3><blockquote><p>用户故事地图是一门在需求拆分过程中保持全景图的技术。</p><p>敏捷软件开发中使用用户故事地图来发现、管理需求</p></blockquote><p><strong>故事地图解决的问题</strong></p><blockquote><ol><li>全局视角缺失</li><li>需求优先级难以确定</li><li>缺乏用户需求聚焦</li><li>难以理解功能之间的关系</li><li>.发布计划不明确</li></ol></blockquote><h3>10.Sprint</h3><ul><li>是 Scrum 的核心，在这里创意（idea）转化为价值。</li><li>固定时长的事件，为期一个月或更短，以保持一致性。前一个 Sprint 结束后，下一个新的Sprint 紧接着立即开始 <ul><li>时间短：“敏捷”，短反馈周期=频繁交付=频繁客户反馈=错误方向=持续时间短=学习改进速度快</li><li>时间长：更多时间作充分准备、解决问题、达成目标，不会被接二连三的会议压的不堪重负</li><li>当前，Scrum 周期通常为2个星期</li></ul></li><li>Sprint计划会议目标</li></ul><blockquote><p>sprint目标、团队成员名单、Sprint backlog、确定好sprint演示日期、确定好时间地点,供举行每日scrum会议</p></blockquote><h3>11.估算</h3><img src="'+n+'" alt="estimate" style="zoom:30%;"><blockquote><p>据收益递减原理，不应在估算上花太多的时间。可以做出一个快速但不那么准确的估计，也可以再多花一点时间做一个更准确的估计</p></blockquote><h4>估算单位(story point)</h4><ul><li>计划扑克</li><li>卡片队列估算法</li></ul><h4>故事与任务</h4><p>Story是可以交付的东西，Task是不可以交付的，Product Owner对Task不关心</p><table><thead><tr><th><strong>Scrum工件</strong></th><th><strong>定义</strong></th><th><strong>对应的承诺</strong></th></tr></thead><tbody><tr><td>Product Backlog</td><td>产品需求动态清单</td><td>Product Goal（产品愿景）</td></tr><tr><td>Sprint Backlog</td><td>Sprint任务计划（目标+选定的条目）</td><td>Sprint Goal（迭代目标）</td></tr><tr><td>Increment</td><td>符合完成标准的可交付成果</td><td>Definition of Done（完成标准）</td></tr></tbody></table><h3>12.燃尽图</h3><img src="'+e+'" alt="燃尽图" style="zoom:50%;"><img src="'+g+'" alt="燃尽图2" style="zoom:75%;"><h3>13.Scrum 优势与局限</h3><blockquote><p>轻量灵活：仅定义必要规则，兼容多种实践</p><p>持续改进：通过事件循环实现经验反馈</p><p>价值驱动：以Product Goal为导向，确保交付有效性</p><p>协作透明：跨角色协作，信息共享最大化</p></blockquote><blockquote><p>没有技术实践</p><p>可以使用极限编程技术实践：测试驱动开发、简单设计、重构、持续集成等等</p></blockquote><h2>XP</h2><blockquote><p>Extreme Programming 这一名称体现了其核心理念：把有益的实践做到极致</p></blockquote><h3>1.XP的核心——开发阶段</h3><blockquote><p>编写代码、运行所有测试用例、迭代测试用例和代码、如果需要，进行重构、集成（包括测试）</p></blockquote><p><strong>说明</strong>：</p><ul><li>结对编程</li><li>测试驱动</li><li>让测试用例运行起来、为系统的分析、设计、实现和测试增加价值</li><li>开发后立即进行集成，包括集成测试</li></ul><h3>2.变更成本曲线</h3><img src="'+u+'" alt="change_cost" style="zoom:75%;"><p><strong>降低变更成本的技术</strong></p><ul><li>OOP</li><li>自动化测试</li><li>重构技术</li><li>CICD：鼓励频繁交付和持续部署</li><li>Beck的曲线并非无视规律，只是把反馈周期从几个月缩短到几分钟，结果就没有机会让成本成指数增长</li><li>平坦曲线的前提是严格执行XP实践</li></ul><p><strong>目标</strong></p><p><img src="'+c+'" alt="XP_cost"></p><h3>3.价值观</h3><h4>交流</h4><blockquote><p>开发者 – 开发者</p><p>开发者 – 客户</p><p>开发则 – 管理层</p></blockquote><p>XP强制要求的沟通方式</p><blockquote><p>单元测试、结对编程、任务估算</p></blockquote><h4>简单</h4><h4>反馈</h4><ul><li>即使反馈 <ul><li>程序员：单元测试</li><li>客户：实时估算</li><li>团队：进度跟踪反馈</li></ul></li><li>中长期反馈 <ul><li>客户：功能测试</li><li>运行软件测试</li></ul></li></ul><h4>勇气</h4><p>以前三个价值观支持</p><h3>4.软件开发的基本内容</h3><img src="'+h+'" alt="coding" style="zoom:30%;"><h4>测试</h4><ul><li>长期来看：测试被运行和维护的前提，让程序运行寿命更长</li><li>短期来看：信心</li><li>类型 <ul><li>单元测试</li><li>客户编写的功能测试？？？？</li></ul></li></ul><h4>倾听</h4><blockquote><p>程序员与业务人员交流、相互之间</p><p>业务人员说明项目的需求、程序员帮助业务人员了解哪些容易、哪些困难</p></blockquote><h4>设计</h4><blockquote><p>低耦合：良好的设计会组织逻辑，以便系统的一部分发生变化并不总是需要系统的另一部分发生变化。</p><p>封装：良好的设计将逻辑放在它所操作的数据附近。</p><p>可扩展性：良好的设计允许系统扩展，且仅在一个地方进行更改。</p></blockquote><h3>5.基本实践</h3><h4>5.1 计划游戏</h4><blockquote><p>业务人员需要决定：范围、优先级、发布的组成、发布日期</p></blockquote><blockquote><p>技术人员需要决定：估算、后果、流程、详细的日程安排</p></blockquote><h4>5.2 小发布</h4><blockquote><p>每次发布都应尽可能小，包含最有价值的业务需求。发布必须作为一个整体有意义。</p></blockquote><h4>5.3 隐喻</h4><blockquote><p>选择一个系统隐喻，通过一致地命名类和方法让团队保持同步</p><p>例如，克莱斯勒薪资系统被构建为一条生产线。</p></blockquote><h4>5.4 简单设计</h4><blockquote><p>运行测试、确保没有重复的逻辑、具有尽可能少的类和方法。反对：“为今天实现，为明天设计。”</p></blockquote><h4>5.5 测试TDD</h4><blockquote><p>程序员编写单元测试——以便他们对程序运行的信心能够成为程序本身的一部分。</p></blockquote><blockquote><p>客户编写功能测试——以便他们对程序运行的信心也能成为程序的一部分。</p></blockquote><h4>5.6 重构 Refactoring</h4><h4>5.7 结对编程</h4><h4>5.8 代码集体拥有制</h4><blockquote><p>任何人若发现有机会为代码的任何部分增加价值，都应随时这么做。</p><p>个人代码所有权模式。</p></blockquote><h4>5.9 CI</h4><h4>5.10 40小时工作制</h4><h4>5.11 现场客户</h4><h4>5.12 编码标准</h4><blockquote><p>程序员极具个人主义，宁愿辞职也不愿把花括号放在别的地方。</p></blockquote><h4>XP做法可行性</h4><h3>6.TDD</h3><p><strong>测试</strong></p><blockquote><ol><li>测试是独立且自动的</li><li>测试应当有价值</li></ol></blockquote><h4>6.1 程序员测试</h4><blockquote><p>程序员逐个方法地编写测试。</p><p>程序员编写的单元测试始终以 100% 的通过率运行。</p><p>由于程序员控制着单元测试的编写和执行，他们能够使测试完全保持同步。</p></blockquote><h4>6.2 客户测试</h4><blockquote><p>客户逐个故事地编写测试。</p><p>客户通常无法自行编写功能测试。极限编程（XP）团队至少要有一名专职测试人员。</p></blockquote><h4>6.3 其他测试</h4><blockquote><p>并行测试：新系统的运行与旧系统完全一致</p><p>压力测试：模拟可能出现的最恶劣负载情况的测试</p><p>随机测试：确保系统自面对无意义输入时能合理响应的测试</p></blockquote><h4>6.4 TDD</h4><p><strong>先写测试再写实现</strong></p><blockquote><p>三阶段循环： 红（失败测试） –&gt; 绿（通过实现） –&gt; 重构（优化代码）</p></blockquote><p><strong>目标</strong>：创建可测试、可维护、最小化的代码</p><p><strong>标准流程</strong></p><blockquote><ol><li>编写失败测试</li><li>快速实现通过</li><li>逐步泛化</li><li>持续重构</li></ol></blockquote><p><strong>核心价值</strong></p><blockquote><p>缺陷预防、设计引导、降低耦合、活的文档</p></blockquote><h3>7. 简单设计的四大准则</h3><blockquote><p>通过所有测试、消除重复、清晰表达意图、最小化元素数量</p></blockquote><p><strong>YAGNI</strong>原则的经济学</p><p><img src="'+b+'" alt="yagni"></p><p><strong>边际成本陷阱</strong></p><blockquote><p>假设开发某功能的当前成本为 $C $</p><p>若提前$N$个周期开发： 总成本 = $ C × (1 + 维护率)^N $</p><p>而实际需求出现时的成本可能仅为$C×0.7$（技术演进）</p></blockquote><p><strong>重构的纪律性</strong></p><blockquote><p>技术 ： 提升可读性、降低维护成本、支持演化式设计</p></blockquote><blockquote><p>工具 ： IDE自动化重构、测试框架、代码质量扫描</p></blockquote><ul><li>重构不是推到重写，而是让代码随时间越变越优雅的持续艺术</li></ul><h4>XP设计</h4><blockquote><p>降低流程中的不可逆性来应对复杂性</p><p>持续保持代码清晰简洁的渴望</p><p>通过重构自信改进代码的能力</p><p>精通模式：不仅理解解决方案，更懂应用时机与演进路径</p><p>预见变化的眼光：知晓今日决策终将改变</p><p>运用代码、图表及最重要的——对话，向相关人员传达设计</p></blockquote><h3>8.持续集成</h3><blockquote><p>持续集成 (Continuous Integration, CI) 是一种软件开发实践，团队成员频繁地（通常每天至少一次）将代码更改集成到共享的代码库主线中。</p></blockquote><h4>8.1 传统集成的特点</h4><ul><li>一个开发者可能对代码库的某个部分做了修改，而另一个开发者基于旧版本的代码进行了开发。</li><li>当这些更改最终汇合时，可能会出现微妙且难以调试的错误。</li><li>开发者：导致尽量减少与其他部分的交互，但这往往会导致技术债的积累和代码质量的下降。</li><li>代码质量和重构 <ul><li>开发者可能会避免进行重要的代码重构</li><li>意识到代码结构存在问题，或者需要清理重复代码，他们也可能因为担心引入集成冲突而选择维持现状</li><li>重构的回避，阻止了代码库根据需求变化和经验积累进行健康的演进</li></ul></li></ul><h4>8.2 CI 的解决方案</h4><blockquote><p>核心理念：持续集成旨在消除传统集成的痛苦</p><p>核心思想：让团队成员非常频繁地集成他们的工作，通常是每天多次</p><p>每次集成涉及的代码量都相对较小，从而显著降低了合并冲突的可能性和复杂性</p><p>快速反馈：任何集成引入的问题都能够被自动化构建和测试快速发现</p><p>CI 鼓励使用主线开发</p></blockquote><h4>8.3 CI 实践示例</h4><ul><li>获取最新代码： 确保本地环境与中央仓库同步是 CI 的基本前提</li><li>本地构建与开发：本地环境中运行完整的自动化构建脚本，包括编译代码和运行所有的自动化测试</li><li>集成前检查：推送（Push）之前，必须再次执行 git pull， 将这些最新的更改合并（Merge）到本地工作副本中，合并后我必须再次在本地运行完整的自动化构建。</li><li>本地构建通过与推送</li></ul><h4>8.4 持续集成的好处</h4><ul><li>降低风险</li></ul><blockquote><p>减少集成风险、快速发现错误、更容易定位错误、减少集成地狱</p></blockquote><ul><li>促进改进与发布</li></ul><blockquote><p>鼓励并支持重构、提高代码质量、更频繁可靠的发布、发布成为业务决策</p></blockquote><h4>CI &amp; CD(Continuous Deployment)</h4><blockquote><p>CI 主要发生在开发环境中、CD是CI的自然延伸，CI是实现CD 的必要前提。</p></blockquote><h2>Kanban</h2><h3>定义</h3><blockquote><p>Kanban 是⼀种优化价值流动 (the flow of value) 的策略，其过程使⽤可视化与拉 式系统</p><p>Kanban 包括以下三个协同⼯作的实践：</p><ul><li>定义与可视化⼯作流</li><li>主动管理⼯作流中的⼯作项 (item)</li><li>改进⼯作流</li></ul></blockquote><blockquote><p>Kanban已被普遍视为与Scrum、XP等并列的重要敏捷实践框架</p><p>运维、持续交付等场景倾向用Kanban；新产品开发常用Scrum</p></blockquote><p><img src="'+a+'" alt="kanban1"></p><h3>可视化工作流</h3><blockquote><p>Kanban 系统成员对于流 的明确且共同的认知，就称为 “⼯作流的定义” (Definition of Workflow，DoW)</p></blockquote><h3>WIP</h3><blockquote><p>Kanban 系统成员须明确地控制在⼯作流中从开始到结束间的⼯作项数量。这种控制称为 “WIP 数量限制”</p></blockquote><blockquote><p>控制 WIP 不仅能够有助于⼯作流，也能够改进 Kanban 系统成员共同的专注、承诺及协作。任何在控制 WIP 时可接受的例外情况都应该作为 DoW 的⼀部分予以 明确说明。</p></blockquote><h3>Kanban 度量</h3><ul><li>WIP：已开始但未完成的⼯作项的数量。</li><li>产能 (Throughput)：每单位时间内完成的⼯作项的数量。 请注意，产能的 度量是对⼯作项的精确计数。</li><li>⼯作项存续时⻓ (Work Item Age)：⼀⼯作项从开始到当前时刻之间所经过 的时间⻓度。</li><li>周期时间 (Cycle time)：⼀⼯作项从开始到完成之间所经过的时间⻓度。</li></ul><h3>Kanban &amp; Scrum</h3><h4>差异</h4><ol><li>框架本质与节奏：</li></ol><ul><li>Scrum: 迭代式 (Iterative)。工作被划分为固定时长（通常2-4周）的<strong>Sprint（冲刺）</strong>。每个Sprint开始时计划需要完成的工作（增量），并在Sprint结束时交付。强制固定节奏（如每日站会、Sprint评审、回顾等）。<strong>优点：</strong> 节奏明确，提供计划性和稳定性，适合有明确交付目标的项目。<strong>限制：</strong> Sprint中<strong>通常拒绝范围变更</strong>。</li><li>Kanban: 流动式 (Flow-based)。没有固定的迭代周期或时间盒限制。工作项从“待办”队列中<strong>持续流动</strong>，完成后拉取下一个高优先级的项。实现<strong>连续交付</strong>。<strong>优点：</strong> 对需求变更反应<strong>极其灵活</strong>，新任务可随时加入队列。<strong>注意：</strong> 团队需<strong>自行建立</strong>回顾、优化等节奏。</li></ul><ol start="2"><li>角色与职责：</li></ol><ul><li>Scrum:规定三个明确角色： <ul><li><strong>产品负责人 (PO):</strong> 最大化产品价值，管理产品待办列表。</li><li><strong>Scrum Master (SM):</strong> 确保团队遵循Scrum流程，移除障碍。</li><li><strong>开发团队：</strong> 跨职能、自组织，负责交付Sprint目标内的增量。<strong>优点：</strong> 职责分工清晰。</li></ul></li><li>Kanban:不指定强制角色。通常保留团队现有组织架构，成员根据职责各司其职（如服务交付经理、服务请求经理等角色是可选项，<strong>非强制</strong>）。<strong>优点：</strong> <strong>灵活性高</strong>，鼓励团队成员<strong>自行协作分配</strong>工作。</li></ul><ol start="3"><li>时间规划与变更处理：</li></ol><ul><li>Scrum: Sprint作为核心时间盒进行计划、评估和交付。<strong>固定节奏会议</strong>（Sprint规划、每日站会、Sprint评审、Sprint回顾）是框架核心。在Sprint进行中，<strong>原则不接受新需求变更</strong>（除非极其特殊情况）。</li><li><strong>Kanban:</strong> <strong>没有时间盒约束</strong>，计划、交付<strong>持续进行</strong>。<strong>需求变更可随时反映</strong>在待办事项队列中，团队根据当前优先级从队列中<strong>拉取</strong>工作。这使其在<strong>处理变更方面异常灵活</strong>。</li></ul><ol start="4"><li>流程、事件与工件：</li></ol><ul><li>Scrum:强调规定的活动（事件）和产出（工件）： <ul><li><strong>事件：</strong> Sprint规划会、每日站会、Sprint评审会、Sprint回顾会。</li><li><strong>工件：</strong> 产品待办列表、Sprint待办列表、增量。<strong>优点：</strong> <strong>提供高度结构化的流程模板</strong>。</li></ul></li><li>Kanban:没有指定强制性的事件或工件 <ul><li>唯一核心工件是看板及相关可视化策略。</li><li>虽鼓励<strong>反馈环</strong>（如运营评审），但频率、形式完全由团队决定。<strong>优点：</strong> <strong>提供灵活的工具箱</strong>，团队按需采用实践，适应性强。</li></ul></li></ul><p>关键</p><ul><li><strong>Scrum：</strong> 更倾向于提供<strong>结构化的框架和纪律</strong>，强调固定的周期、明确的角色和清晰的事件，为团队提供可预测的节奏，但牺牲了对范围变更的即时响应。</li><li><strong>Kanban：</strong> 更侧重于<strong>流程可视化和限制在制品 (WIP)</strong>，核心价值是<strong>最大化流动和响应变化</strong>。它提供了一套灵活的实践工具，对角色、会议、时间节奏要求极低，但要求团队具备更强的自我管理和持续改进能力。</li></ul><h2>DevOps</h2><h3>1. 发展背景</h3><blockquote><p>传统困境: 开发与运维各自为政，缺乏协作；开发专注新功能，运维负责部署维护</p></blockquote><hr><h3>2. DevOps概述 与 CI / CD</h3><blockquote><p>DevOps 不仅是理念: 更是一系列核心实践和技术工具的体系化应用，贯穿软件生命周期</p><p>规划、编码、构建、测试、发布、部署、运行、监控、反馈——形成持续循环的不间断流程</p></blockquote><h4>CI</h4><blockquote><p>Continuous Integration: 要求开发者频繁 (每天乃至每小时) 将代码变更合并到主干分支，触发自动化构建和测试。</p></blockquote><h4>CD</h4><blockquote><p>Continuous Delivery: 将 CI 产出的构件自动部署到测试或预生产环境。</p></blockquote><h4>持续部署（进阶CD）</h4><blockquote><p>持续交付的极致，代码通过自动化流程验证后直接部署到生产环境。</p></blockquote><hr><h3>3.测试自动化与 IaC</h3><ul><li><p><strong>自动化测试</strong>：作为“测试门禁”，只有通过测试的构建才可部署，确保缺陷前移。</p></li><li><p>基础设施——代码 (<strong>IaC</strong>- Infrastructure as Code):</p><ul><li>用代码管理基础设施（服务器、网络等），替代手动操作</li><li>效果：确保环境一致性，避免配置漂移，支持版本控制与审计。</li></ul></li></ul><hr><h3>4.配置管理、容器化</h3><ul><li><strong>配置管理工具</strong>： Chef/Puppet统一管理服务器配置。</li><li><strong>容器化（Docker）</strong>： 应用与依赖打包为镜像，实现“一次构建，到处运行”，解决环境差异问题。</li><li><strong>容器编排（Kubernetes）</strong>： 自动化管理容器集群，支持微服务架构的弹性伸缩与服务发现。</li></ul><hr><h3>5. 监控反馈</h3><ul><li><strong>实时监控</strong>： 工具（Prometheus, Grafana）收集性能指标、日志、用户行为数据，设置告警。</li><li><strong>持续反馈（CF）</strong>： 不仅响应故障（降低MTTR），更将运行数据用于优化（如分析部署频率与失败率关系）。</li><li><strong>闭环流程</strong>： 形成 <strong>CI-CD-CF</strong> 自动化循环，核心是协作透明与文化驱动。</li></ul><blockquote><p>DevOps 核心实践形成 CI-CD-CF (持续反馈) 闭环。</p><p>高度自动化是显著特征；协作和透明是关键。</p><p>依赖工具链支撑，将工具和实践融合成文化和流程，实现“更快地交付更可靠的软件”</p></blockquote><hr><h3>6. 与其他的方法对比</h3><h4>6.1 DevOps vs. 敏捷（Agile）</h4><ul><li><strong>敏捷</strong>：项目和产品开发方法学，提高开发过程灵活性和响应速度。 <ul><li>关注点：开发团队内部效率 (每日站会、短迭代、用户故事驱动)，与客户持续反馈，快速响应需求变更。</li><li>目标：“如何更有效地开发软件”。</li></ul></li><li><strong>DevOps</strong>：扩展敏捷理念，范围从开发延伸到软件交付和运维全生命周期。 <ul><li>关注点：开发与运维协作，打破壁垒，实现从开发到部署的持续流动。</li><li>目标：“如何更快更可靠地交付软件”。</li></ul></li><li><strong>关系</strong>：二者互补，敏捷强调组织结构和开发流程敏捷性，DevOps 强调跨职能协作和交付流程自动化。</li></ul><h4>6.2 DevOps vs. CI/C</h4><ul><li><strong>CI/CD</strong>：是自动化技术实践（代码构建、测试、部署）。</li><li><strong>DevOps</strong>：涵盖文化、流程、工具的整体理念，CI/CD是其核心实现手段。</li></ul><h4>6.3 DevOps vs. 云原生（Cloud Native）</h4><blockquote><p>云原生定义：利用云计算优势设计部署应用的架构理念 (容器化、微服务、不可变基础设施等)。强调应用如何构建运行以适应云环境弹性和分布式特性。</p></blockquote><ul><li><strong>云原生</strong>：关注架构设计（容器化、微服务、不可变基础设施）。</li><li><strong>DevOps</strong>：强调应用如何快速可靠交付。</li><li><strong>协同</strong>：云原生架构依赖DevOps实践（如微服务需CI/CD），DevOps需云资源弹性支持。云原生关注架构，DevOps 关注流程。</li></ul><h4>6.4 DevOps vs. AIOps</h4><blockquote><p>AIOps 定义：利用 AI 技术提升 IT 运维智能化水平 (机器学习分析监控数据、自动发现异常、定位根因等)</p></blockquote><ul><li><strong>AIOps</strong>：用AI优化运维（故障预测、自动恢复）。</li><li><strong>DevOps</strong>：提供自动化流程与文化基础，为AIOps提供数据支撑。</li><li><strong>关系</strong>：AIOps增强DevOps运维效率（如缩短MTTR），DevOps为AI落地铺路。</li></ul><hr><h3>7. DevSecOps：安全左移实践</h3><h4>7.1 核心理念</h4><ul><li><strong>安全左移（Shift Left Security）</strong>： 将安全集成到开发全周期，而非发布前检查。</li><li><strong>文化转变</strong>： 安全成为开发/运维团队的共同责任，而非独立环节。</li></ul><h4>7.2. 关键实践</h4><ul><li><strong>规划阶段</strong>：需求评审纳入安全标准，团队协作定义风险。</li><li>开发阶段： <ul><li>安全编码培训 + 静态扫描（SAST）工具集成。</li><li>第三方依赖漏洞扫描（SCA）。</li></ul></li><li><strong>CI流水线</strong>： 自动化安全测试（SAST/DAST）、容器镜像扫描。</li><li><strong>基础设施</strong>： 用IaC实施安全策略（如端口限制），代码化审计。</li><li><strong>运行监控</strong>： WAF、入侵检测实时防护，安全事件闭环反馈至开发。</li></ul><hr><h3>8. 核心术语表</h3><table><thead><tr><th style="text-align:left;"><strong>术语</strong></th><th style="text-align:left;"><strong>定义与应用</strong></th></tr></thead><tbody><tr><td style="text-align:left;">蓝绿部署</td><td style="text-align:left;">零停机策略：维护两套环境（蓝=当前生产，绿=新版），验证后瞬时切换流量，回滚快但资源成本高。</td></tr><tr><td style="text-align:left;"><strong>金丝雀发布</strong></td><td style="text-align:left;">渐进式部署：先导流少量用户到新版，逐步扩大范围，风险最低，常结合A/B测试。</td></tr><tr><td style="text-align:left;">基础设施即代码(IaC)</td><td style="text-align:left;">用脚本定义资源（Terraform），版本控制+自动化部署，确保环境一致性。</td></tr><tr><td style="text-align:left;">微服务</td><td style="text-align:left;">架构拆分为独立服务，由小团队全生命周期负责，依赖DevOps实现高频部署与监控。</td></tr><tr><td style="text-align:left;">持续监控</td><td style="text-align:left;">实时收集性能/日志数据（Prometheus, ELK），驱动优化迭代。</td></tr></tbody></table><hr><h3>9. DORA效能指标</h3><blockquote><ol><li><strong>部署频率</strong>：生产环境成功部署频次（日/周/月）。</li></ol></blockquote><img src="'+k+'" alt="dora1" style="zoom:33%;"><blockquote><ol start="2"><li><strong>变更前置时间</strong>：代码提交到部署的时长。</li></ol></blockquote><img src="'+q+'" alt="dora2" style="zoom:33%;"><blockquote><ol start="3"><li><strong>变更失败率</strong>：部署后引发故障的比例。</li></ol></blockquote><img src="'+d+'" alt="dora3" style="zoom:33%;"><blockquote><ol start="4"><li><strong>平均恢复时间（MTTR）</strong>：故障修复效率。</li></ol></blockquote><img src="'+m+'" alt="dora4" style="zoom:33%;"><h2>敏捷</h2><p><img src="'+S+'" alt="it_dev"></p><p><img src="'+D+'" alt="agile"></p><hr><h3>1. 敏捷的本质与目标</h3><p><strong>1.1 核心定义</strong></p><ul><li><strong>应对复杂性</strong>：承认软件开发具有天然复杂性（需求模糊、快速变化），无法通过前期充分准备消除风险。</li><li><strong>价值驱动</strong>：以<strong>为客户创造价值</strong>为最高成功标准，而非传统&quot;按时按预算交付&quot;。</li><li>反传统观点： <ul><li>传统成功标准：按时、不超预算、功能符合设计。</li><li>敏捷成功标准：<strong>项目收益最大化</strong>（如Google Earth收益5000万＞成本100万，延期可接受）。</li></ul></li></ul><p><strong>1.2 适用场景</strong></p><ul><li>需求模糊、市场快速变化的领域（互联网、移动应用等）。</li><li>需快速迭代验证产品的创新项目（如精益创业模式）。</li></ul><hr><h3>2. 价值观→原则→实践</h3><table><thead><tr><th><strong>层级</strong></th><th><strong>核心内容</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><strong>价值观</strong></td><td>沟通、简单、反馈、勇气、尊重（XP五大价值观）</td><td>指导决策方向，避免实践僵化</td></tr><tr><td><strong>原则</strong></td><td>桥梁作用，如：快速反馈、及早交付、拥抱变化、简洁为本</td><td>将价值观转化为可操作指南</td></tr><tr><td><strong>实践</strong></td><td>TDD、持续集成、站会、看板、用户故事等</td><td>具体落地手段</td></tr></tbody></table><blockquote><p><strong>类比说明</strong>：</p><ul><li><strong>价值观</strong> = 园艺师对 “好花园” 的整体判断</li><li><strong>原则</strong> = 何时剪枝/移栽的决策依据</li><li><strong>实践</strong> = 掘土/灌溉的具体操作</li></ul></blockquote><hr><h3>3. 敏捷软件开发宣言</h3><p><strong>3.1 个体和互动 &gt; 流程工具</strong></p><ul><li>强调<strong>人的自主性</strong>：团队自主选择实践（如计划扑克），反对强制流程。</li><li>工具服务于协作，而非限制创新。</li></ul><p><strong>3.2 可工作软件 &gt; 详尽文档</strong></p><ul><li>文档需创造价值（如用户文档），拒绝形式化流程文档。</li><li>计划载体：用户故事、看板、验收测试等&quot;轻量级&quot;形式。</li></ul><p><strong>3.3 客户合作 &gt; 合同谈判</strong></p><ul><li>开发方与客户是<strong>价值共创伙伴</strong>，非对立关系。</li><li>通过持续反馈调整需求（例：每周演示迭代成果）。</li></ul><p><strong>3.4 响应变化 &gt; 遵循计划</strong></p><ul><li>拥抱需求变更，视变化为<strong>竞争优势来源</strong>。</li><li>反对僵化的&quot;变更控制流程&quot;。</li></ul><hr><h3>4. 创新、研发、运维</h3><p><img src="'+C+'" alt="agile2"></p><blockquote><p><strong>核心结论</strong>：敏捷是<strong>以价值为导向、适应复杂性的思维模式</strong>，其生命力在于价值观引领下的持续实践优化。</p></blockquote><h2>新方法学</h2><hr><h3>1. 从无、到繁重、再到敏捷</h3><blockquote><p>当系统变得越大越复杂时，要想加入新的功能就越来越困难。同时错误故障越来越多，越来越难于排除。</p></blockquote><hr><h3>2. 预见性与适应性</h3><ul><li>将设计与建造分离开来 <ul><li><em>工程误区</em>：假设软件可像建筑一样分离设计（文档）与建造（编码）。</li><li><em>现实</em>：软件“建造”（编译）成本极低，编码本质是设计活动。</li></ul></li><li>需求的不可预见性</li><li>预见性是不可能的吗？ <ul><li>需求稳定的特殊场景（如航天系统）可保留预见性方法。</li></ul></li><li>不可预见过程的控制 － 迭代 <ul><li><strong>解决方案</strong>：短周期迭代（1-4周），持续交付可运行软件，快速反馈调整。</li></ul></li><li>适应性的客户 <ul><li>客户深度参与：固定时间与预算，灵活调整范围，优先高价值需求。</li></ul></li></ul><hr><h3>3. 把人放在第一位</h3><ul><li>可兼容性程序插件</li><li>程序员是负责任的专业人员</li><li>面向人的开发过程的管理</li><li>度量的困难性 <ul><li>传统度量（如代码行数）失效，聚焦结果（可运行软件）而非过程。</li></ul></li><li>业务专家的引领作用</li><li>自适应过程</li><li>敏捷开发的不同风格</li></ul>',260)])))}};export{T as category,O as date,K as default,A as summary,P as updated};
