const n=`---
date: 2025-06-01
updated: 2025-06-03
category: 基础知识
summary: 救命，球球了
---
# 球球了

## c++

### 构造函数和析构函数

- 与类同名；没有返回类型（连 void 也没有）；可以有参数，可以重载；如果用户没有定义，编译器会生成一个默认构造函数

- 类名前加 \`~\`；没有返回类型；没有参数，不能重载；如果用户没有定义，编译器会生成一个默认析构函数

  
### malloc 和 构造函数

| 特性     | malloc          | 构造函数                  |
| -------- | --------------- | ------------------------- |
| 所属语言 | C 语言函数      | C++ 类成员函数            |
| 功能     | 仅分配原始内存  | 分配内存并初始化对象      |
| 初始化   | 不调用构造函数  | 自动调用构造函数初始化    |
| 返回类型 | \`void*\`         | 无返回类型                |
| 内存来源 | 堆内存          | 取决于使用方式（堆/栈等） |
| 关联操作 | 需要配合 \`free\` | 自动关联析构函数          |

如果必须使用 \`malloc\`，需要手动初始化
1. 对象状态：构造函数初始化对象内部状态，\`malloc\` 创建的对象可能包含垃圾值
2. 资源管理：构造函数可能申请其他资源（如打开文件），\`malloc\` 不会处理这些



### malloc返回的地址

| 关键点                   | 说明                                                 |
| ---------------------------- | -------------------------------------------------------- |
| malloc 返回虚拟地址          | 程序看到的是进程虚拟地址空间中的地址                     |
| 物理地址由OS和MMU管理        | 应用程序无法直接访问物理地址                             |
| 物理内存分配发生在首次访问时 | 通过缺页中断（Page Fault）由OS分配物理页框               |
| 虚拟内存机制提供安全和灵活性 | 隔离进程、支持内存超额分配（Overcommit）、换页（Swap）等 |





### 关键字 volatile

告诉编译器不要优化某一个变量，防止编译器错误优化，确保每次访问变量时都从内存读取，而不是使用寄存器中的缓存值。

- \`const\`：变量不可被程序修改（但可能被硬件/外部修改）。
- \`volatile\`：变量可能被外部修改，编译器不要优化。









### 关键字 static 和extern 

\`\`\`c
// file1.c
int global_var = 10; // 全局变量，可以被其他文件访问

// file2.c
extern int global_var; // 声明，告诉编译器变量在别处定义

void func() {
    printf("%d\\n", global_var); // 可以访问
}
\`\`\`

| 特性                 | 全局变量               | static 全局变量        |
| -------------------- | ---------------------- | ---------------------- |
| 作用域               | 整个程序（多文件可见） | 仅当前文件             |
| 链接性               | 外部链接（external）   | 内部链接（internal）   |
| 能否被 \`extern\` 引用 | ✅ 可以                 | ❌ 不可以               |
| 存储位置             | 全局/静态存储区        | 全局/静态存储区        |
| 默认初始值           | 0 / NULL               | 0 / NULL               |
| 用途                 | 跨文件共享数据         | 限制变量仅当前文件使用 |

---

为什么用 \`static\` 全局变量？
1. 避免命名冲突：
   - 如果多个文件定义了同名全局变量，会导致链接错误。
   - 使用 \`static\` 可以确保变量只在当前文件有效。

2. 隐藏实现细节：
   
3. 替代全局变量：
   - 如果变量只需要在当前文件使用，优先用 \`static\` 全局变量，而不是普通全局变量。

\`static\` 的其他用法
\`static\` 关键字在 C/C++ 中还有另外两种用法：

1. \`static\` 局部变量：
   - 在函数内部定义，生命周期延长到整个程序运行期间。
   - 但作用域仍然仅限于函数内部。
   \`\`\`c
   void func() {
       static int count = 0; // 只初始化一次
       count++;
   }
   \`\`\`

2. \`static\` 成员变量（C++ 类）：
   - 属于类本身，而不是类的实例。
   - 所有对象共享同一个 \`static\` 成员变量。
   \`\`\`cpp
   class MyClass {
   public:
       static int shared_var; // 类变量
   };
   \`\`\`



### define 宏定义和 typedef 

| 特性         | \`#define\`（宏）        | \`typedef\`（类型别名） |
| ---------------- | ---------------------- | --------------------- |
| 处理阶段     | 预处理阶段（文本替换） | 编译阶段（类型检查）  |
| 用途         | 常量、宏、代码片段     | 仅用于类型别名    |
| 类型安全     | ❌ 无类型检查           | ✅ 有类型检查          |
| 作用域       | 文件作用域（全局）     | 遵循变量作用域规则    |
| 是否需要分号 | ❌ 不需要               | ✅ 需要                |
| 调试友好性   | ❌ 错误信息可能不直观   | ✅ 错误信息更清晰      |
| 适用场景     | 常量、条件编译、宏函数 | 简化复杂类型声明      |

### 什么是虚函数表？

- 虚函数表是一个存储类虚函数指针的数组
- 每个包含虚函数的类（或从包含虚函数的类继承的类）都有自己的虚函数表
- 虚函数表在编译时创建，存储在程序的只读数据段

以下是关于C++虚函数表(vtable)、虚继承(virtual inheritance)及相关知识的综合总结，结合文字说明和图表展示：

---

### 1. 虚函数表（vtable）机制
#### 核心概念
- 作用：实现运行时多态（动态绑定）
- 存储位置：只读数据段（编译期生成）
- 组成元素：
  \`\`\`plaintext
  vtable = [虚函数1指针, 虚函数2指针, ..., 虚析构函数指针]
  \`\`\`

#### 内存结构示例
\`\`\`cpp
class Base {
public:
    virtual void f1() {}
    virtual void f2() {}
};
class Derived : public Base {
public:
    void f1() override {}
    virtual void f3() {}
};
\`\`\`

内存布局：
\`\`\`mermaid
classDiagram
    class Base_vtable {
        +Base::f1()
        +Base::f2()
    }
    class Derived_vtable {
        +Derived::f1()  // 覆盖
        +Base::f2()     // 继承
        +Derived::f3()  // 新增
    }
    Base --> Base_vtable
    Derived --> Derived_vtable
\`\`\`

#### 关键特性
| 特性     | 说明                      |
| -------- | ------------------------- |
| vptr位置 | 对象首部（通常4/8字节）   |
| 构造顺序 | 基类→派生类（初始化vptr） |
| 调用成本 | 多一次指针解引用          |

---

### 2. 虚继承（Virtual Inheritance）
#### 菱形继承问题
\`\`\`mermaid
graph TD
    A[Base] --> B[Derived1]
    A --> C[Derived2]
    B --> D[FinalDerived]
    C --> D
\`\`\`

问题表现：
- 数据冗余：FinalDerived包含两份Base成员
- 二义性：\`finalObj.Base::data\` 访问不明确

#### 虚继承解决方案
\`\`\`cpp
class Derived1 : virtual public Base {};
class Derived2 : virtual public Base {};
\`\`\`

内存布局：
\`\`\`plaintext
FinalDerived对象:
+----------------+
| Derived1部分    |
| Derived2部分    |
| vbase_ptr1     |--> 共享的Base子对象
| vbase_ptr2     |
| FinalDerived数据|
+----------------+
\`\`\`

#### 构造函数调用顺序
1. 虚基类（Base）
2. 非虚基类（Derived1/Derived2）
3. 成员对象
4. 自身构造函数

#### 5. 重要规则总结
1. 虚函数表规则：
   - 每个多态类一个vtable
   - 子类重写会覆盖父类函数指针
   - 新增虚函数追加到vtable末尾

2. 虚继承规则：
   - 虚基类由最派生类直接初始化
   - 共享基类子对象位于派生类尾部
   - 通过虚基类指针间接访问

3. 设计建议：
   - 优先用组合替代多重继承
   - 基类析构函数必须为虚函数
   - 避免深层次的虚继承层次





### 协程(Coroutine)详解

协程是一种比线程更加轻量级的并发编程模型，它通过协作式多任务而非抢占式多任务来实现并发执行。

#### 1. 定义
协程是可以暂停执行和恢复执行的函数，它能在任意位置挂起(yield)，并在之后从挂起处恢复(resume)。

#### 2. 核心特点
- 用户态调度：由程序员控制切换，不需要内核介入
- 极低开销：上下文切换只需保存少量寄存器(约100字节)
- 同步编码风格：用看似同步的代码实现异步逻辑
- 无锁编程：天然避免多线程的竞态条件

#### 3. 与线程对比

| 特性         | 线程                 | 协程                 |
| ------------ | -------------------- | -------------------- |
| 调度方式 | 抢占式(操作系统控制) | 协作式(程序员控制)   |
| 切换开销 | 高(需内核介入)       | 极低(纯用户态操作)   |
| 并发规模 | 通常数百到数千       | 轻松支持数十万并发   |
| 内存占用 | MB级(默认栈大小)     | KB级(可自定义栈大小) |
| 数据共享 | 需要同步机制         | 天然单线程无竞争     |


存储协程运行状态的数据结构：
\`\`\`c
struct coroutine {
    void* stack_ptr;    // 栈指针
    void* stack_base;   // 栈基址
    void* resume_point; // 恢复点(IP)
    int status;         // 状态(运行/挂起/结束)
};
\`\`\`

#### 优点
1. 超高并发：单机支持数十万协程
2. 低资源消耗：每个协程只需KB级内存
3. 简化异步代码：用同步方式写异步逻辑
4. 无锁编程：避免多线程竞争问题

#### 缺点
1. 不能利用多核：本质仍是单线程(可通过多线程+协程池解决)
2. 阻塞操作危险：一个协程阻塞会导致整个线程阻塞
3. 调试困难：调用栈可能不连续
4. 生态系统支持：部分语言/库支持不完善











### sizeof  & strlen

| 特性         | sizeof                    | strlen                       |
| ------------ | ------------------------- | ---------------------------- |
|类型     | 运算符（编译时确定）      | 函数（运行时计算）           |
|作用对象 | 任何数据类型或变量        | 仅适用于字符串（以'\\0'结尾） |
|计算内容 | 对象/类型占用的内存字节数 | 字符串的实际长度（不含'\\0'） |
|计算时机 | 编译时                    | 运行时                       |
|参数     | 类型名或表达式            | 字符指针（char*）            |
|头文件   | 不需要（语言内置）        | 需要#include <string.h>      |
|效率     | 无运行时开销              | 需要遍历字符串直到'\\0'       |





### 重载和重写

#### 1. 基本

| 特性       | 重载(Overload)                 | 重写(Override)             |
| ---------- | ------------------------------ | -------------------------- |
|定义   | 同一作用域内同名函数的不同实现 | 派生类重新定义基类的虚函数 |
|目的   | 提供处理不同参数类型的同名函数 | 实现运行时多态             |

\`\`\`cpp
class Calculator {
public:
    int add(int a, int b) { return a + b; }
    double add(double a, double b) { return a + b; }  // 重载add函数
    int add(int a, int b, int c) { return a + b + c; } // 参数数量不同
};
\`\`\`

\`\`\`cpp
class Base {
public:
    virtual void show() { cout << "Base show" << endl; }
};

class Derived : public Base {
public:
    void show() override { cout << "Derived show" << endl; }  // 重写show函数
};
\`\`\`

#### 2.override关键字：

   - 显式声明重写，编译器会检查是否正确重写
   \`\`\`cpp
   class Derived : public Base {
   public:
       void show() override;  // 如果Base没有virtual show()，会编译错误
   };
   \`\`\`

#### 3.final关键字：

   - 禁止派生类重写该函数
   \`\`\`cpp
   class Base {
   public:
       virtual void foo() final;  // 派生类不能重写foo()
   };
   \`\`\`



### 虚函数和纯虚函数

#### 虚函数示例
\`\`\`cpp
class Animal {
public:
    virtual void makeSound() {  // 虚函数有默认实现
        cout << "Some animal sound" << endl;
    }
};

class Cat : public Animal {
public:
    void makeSound() override {  // 可选择重写
        cout << "Meow" << endl;
    }
};
\`\`\`

#### 纯虚函数示例
\`\`\`cpp
class Shape {  // 抽象类
public:
    virtual double area() const = 0;  // 纯虚函数
};

class Circle : public Shape {
    double radius;
public:
    Circle(double r) : radius(r) {}
    double area() const override {  // 必须实现
        return 3.14159 * radius * radius;
    }
};
\`\`\`

#### 使用虚函数的情况
- 当基类可以提供有意义的默认实现时
- 当派生类可能需要也可能不需要特殊行为时
- 实现模板方法设计模式

#### 使用纯虚函数的情况
- 定义接口规范（类似Java接口）
- 强制派生类实现特定功能
- 当基类无法提供有意义的默认实现时
- 实现策略模式或抽象工厂模式

#### attention
1. 构造函数不能是虚函数或纯虚函数
2. 析构函数应该是虚函数（特别是基类有虚函数时）



### 智能指针

C++11 引入了三种主要的智能指针，定义在 \`<memory>\` 头文件中：

1. \`std::unique_ptr\` - 独占所有权指针
2. \`std::shared_ptr\` - 共享所有权指针
3. \`std::weak_ptr\` - 弱引用指针（配合 shared_ptr 使用）

| 特性           | unique_ptr             | shared_ptr           | weak_ptr               |
| -------------- | ---------------------- | -------------------- | ---------------------- |
| 所有权     | 独占                   | 共享                 | 无所有权               |
| 引用计数   | 无                     | 有                   | 不增加引用计数         |
| 性能开销   | 最小（几乎等同裸指针） | 中等（维护引用计数） | 中等                   |
| 线程安全   | 非线程安全             | 引用计数原子操作安全 | 同 shared_ptr          |
| 循环引用   | 无此问题               | 可能导致循环引用     | 解决循环引用问题       |
| 是否可复制 | 不可复制（可移动）     | 可复制               | 可复制                 |
| 是否可空   | 可置空                 | 可置空               | 必须从 shared_ptr 创建 |
| 释放时机   | 离开作用域或显式释放   | 引用计数为0时        | 不影响对象生命周期     |

#### 3.1 std::unique_ptr

适用场景：
- 替代原始指针管理独占资源
- 工厂函数返回资源
- 作为类的成员变量，表示独占资源
- 需要明确资源所有权转移的情况

示例：
\`\`\`cpp
// 创建 unique_ptr
std::unique_ptr<MyClass> ptr(new MyClass());
// 或者使用 make_unique (C++14)
auto ptr = std::make_unique<MyClass>();

// 转移所有权
std::unique_ptr<MyClass> ptr2 = std::move(ptr);
\`\`\`

#### 3.2 std::shared_ptr

适用场景：
- 多个对象需要共享同一资源
- 需要共享所有权的复杂数据结构
- 需要将指针存入标准容器
- 需要共享访问但不明确资源生命周期的情况

示例：
\`\`\`cpp
// 创建 shared_ptr
std::shared_ptr<MyClass> ptr1(new MyClass());
// 推荐使用 make_shared
auto ptr2 = std::make_shared<MyClass>();

// 复制共享
auto ptr3 = ptr2;  // 引用计数+1
\`\`\`

#### 3.3 std::weak_ptr

适用场景：
- 打破 shared_ptr 的循环引用
- 观察 shared_ptr 管理的对象而不影响其生命周期
- 缓存系统中需要知道对象是否还存在

示例：
\`\`\`cpp
auto shared = std::make_shared<MyClass>();
std::weak_ptr<MyClass> weak = shared;

// 使用时检查并转换为 shared_ptr
if (auto temp = weak.lock()) {
    temp->doSomething();  // 安全使用
}
\`\`\`

\`\`\`cpp
class B;

class A {
public:
    std::shared_ptr<B> b_ptr;
    ~A() { std::cout << "A destroyed\\n"; }
};

class B {
public:
    std::shared_ptr<A> a_ptr;  // 改为 weak_ptr 可解决问题
    ~B() { std::cout << "B destroyed\\n"; }
};

void circularReference() {
    auto a = std::make_shared<A>();
    auto b = std::make_shared<B>();
    a->b_ptr = b;
    b->a_ptr = a;  // 循环引用，对象不会被销毁
}
\`\`\`

1. \`unique_ptr\`：几乎无额外开销
2. \`shared_ptr\`：
   - 引用计数操作有少量开销
   - \`make_shared\` 可合并内存分配（对象和控制块）
3. \`weak_ptr\`：与 \`shared_ptr\` 类似，但访问需要临时转换



---





### new

在 C++ 中，使用 \`new\` 关键字分配出来的对象，会被存放在 堆（Heap） 上.

| 内存区域    | 说明                                             | 示例                         |
| ----------- | ------------------------------------------------ | ---------------------------- |
| 栈（Stack） | 函数调用时的局部变量，自动分配，生命周期随作用域 | \`int a = 10;\`                |
| 堆（Heap）  | 手动分配，生命周期由程序员控制                   | \`int* p = new int(10);\`      |
| 全局/静态区 | 全局变量、静态变量存放区                         | \`static int x = 1;\`          |
| 常量区      | 字符串常量和 const 修饰的全局常量等              | \`const char* str = "hello";\` |
| 代码区      | 存放程序的机器指令（函数体）                     | \`void func() {}\`             |

------



### map 和 unordered_map

- \`map\` 是红黑树实现（有序），操作复杂度 O(log n)
- \`unordered_map\` 是哈希表实现（无序），操作复杂度平均 O(1)，最坏 O(n)





### 内存泄漏和内存溢出的概率

- 内存泄漏是指程序在运行过程中，由于某些原因未能释放不再使用的内存，导致这部分内存无法被重新利用的现象。

    - > 可以使用 Valgrind 或 AddressSanitizer 等工具定位泄漏，也可以重载 new/delete 做日志追踪。实际开发中推荐使用智能指针（如 \`std::unique_ptr\`）从源头预防泄漏。
- 内存溢出是指程序在申请内存时，没有足够的内存空间供其使用，导致程序无法正常执行的现象。



### 四种类型转换

| 类型               | 安全性 | 用途                      | 检查机制   |
| ------------------ | ------ | ------------------------- | ---------- |
| \`static_cast\`      | 较安全 | 普通类型、安全类转换      | 编译期检查 |
| \`dynamic_cast\`     | 安全   | 多态类间安全转换          | 运行时检查 |
| \`const_cast\`       | 中等   | 添加/去除 const、volatile | 编译期检查 |
| \`reinterpret_cast\` | 危险   | 指针、整型等底层转换      | 无检查     |



### 右值引用和完美转发



### 宏和模板

\`\`\`cpp
#include <iostream>

// 宏定义：简单文本替换
#define SQUARE_MACRO(x) ((x) * (x))

// 模板函数：类型安全，编译期检查
template<typename T>
T square_template(T x) {
    return x * x;
}

int main() {
    int a = 5;
    double b = 3.14;

    // 使用宏
    std::cout << "宏 SQUARE_MACRO(a): " << SQUARE_MACRO(a) << std::endl;
    std::cout << "宏 SQUARE_MACRO(b): " << SQUARE_MACRO(b) << std::endl;

    // 使用模板
    std::cout << "模板 square_template(a): " << square_template(a) << std::endl;
    std::cout << "模板 square_template(b): " << square_template(b) << std::endl;

    // 宏副作用示例
    int c = 4;
    std::cout << "宏副作用 SQUARE_MACRO(c++): " << SQUARE_MACRO(c++) << std::endl; 
    std::cout << "c 的值: " << c << std::endl;

    // 模板不会有这种问题
    int d = 4;
    std::cout << "模板 square_template(d++): " << square_template(d++) << std::endl;
    std::cout << "d 的值: " << d << std::endl;

    return 0;
}

\`\`\`



### 内存对齐

#### 1. \`#pragma pack\`

\`\`\`
cpp复制编辑#pragma pack(1)
struct B {
    char a;
    int b;
};
#pragma pack()
\`\`\`

这个结构体将没有填充字节，总大小为 5 字节（但会影响性能甚至兼容性）。

#### 2. alignas（C++11）

\`\`\`
cpp复制编辑struct alignas(16) MyStruct {
    int a;
    double b;
};
\`\`\`

强制将 \`MyStruct\` 对齐到 16 字节边界。

> 内存对齐是为了让数据在内存中按一定边界排列，提高 CPU 访问效率，某些平台甚至要求必须对齐。C++ 中结构体会自动按成员最大对齐方式补充填充字节，我们可以使用 \`#pragma pack\` 或 \`alignas\` 显式控制对齐方式。合理对齐既能优化性能，也可避免跨平台问题。



## python

### Global Interpreter Lock

GIL 保证任意时刻只有一个线程在执行 Python 字节码。

解决 GIL 限制的方法

1. 多进程（multiprocessing）：
    - 每个进程都有自己的 Python 解释器和 GIL，可以真正并行运行。
    - 适合 CPU 密集型任务。
2. 使用 C 扩展释放 GIL：
    - 第三方库（如 NumPy、TensorFlow）在内部用 C 写的部分会主动释放 GIL，从而实现并行。












## MySQL

\`\`\`
表A           表B
+----+-----+   +----+------+
| id | 名字 |   | id | 年龄 |
+----+-----+   +----+------+
| 1  | 张三 |   | 1  | 20   |
| 2  | 李四 |   | 4  | 22   |
| 3  | 王五 |   | 2  | 21   |
+----+-----+   +----+------+
\`\`\`

🎯 内连接：

\`\`\`sql
SELECT * FROM A INNER JOIN B ON A.id = B.id;
\`\`\`

\`\`\`
+----+-----+------+ 
| id | 名字 | 年龄 | 
+----+-----+------+
| 1  | 张三 | 20   |
| 2  | 李四 | 21   |
+----+-----+------+
\`\`\`

🎯左连接 ：返回左表所有数据，即使右表无匹配数据也返回 NULL。

\`\`\`sql
SELECT * FROM A LEFT JOIN B ON A.id = B.id;
\`\`\`

\`\`\`
+----+-----+------+
| id | 名字 | 年龄 |
+----+-----+------+
| 1  | 张三 | 20   |
| 2  | 李四 | 21   |
| 3  | 王五 | NULL |
+----+-----+------+
\`\`\`

------

🎯右连接： 返回右表所有数据，即使左表无匹配也返回 NULL。

\`\`\`sql
SELECT * FROM A RIGHT JOIN B ON A.id = B.id;
\`\`\`


\`\`\`
+----+-----+------+
| id | 名字 | 年龄 |
+----+-----+------+
| 1  | 张三 | 20   |
| 2  | 李四 | 21   |
| 3  | NULL | 22   |
+----+-----+------+
\`\`\`

------

🎯全连接:不原生支持 FULL OUTER JOIN，但可通过 \`UNION\` 模拟实现：

\`\`\`sql
SELECT * FROM A LEFT JOIN B ON A.id = B.id
UNION
SELECT * FROM A RIGHT JOIN B ON A.id = B.id;
\`\`\`

\`\`\`
+----+-----+------+
| id | 名字 | 年龄 |
+----+-----+------+
| 1  | 张三 | 20   |
| 2  | 李四 | 21   |
| 3  | 王五 | NULL |
| 4  | NULL | 22   |
+----+-----+------+
\`\`\`

### 事务的特性

- 原子性、隔离性、一致性、持久性





### 索引

#### 主键索引

####  辅助索引（非聚簇索引）

#### B+树

#### 哈希映射



### 日志


| 日志类型                    | 对应事务特性             | 说明                             |
| ----------------------- | ------------------ | ------------------------------ |
| Redo Log（重做日志）      | 🧱 持久性（Durability） | 保证事务提交后数据不会丢失，崩溃恢复时可重做已提交事务    |
| Undo Log（回滚日志）      | 💥 原子性（Atomicity）  | 支持事务失败时回滚；也参与一致性与多版本隔离（MVCC）   |
| Binlog（二进制日志）       | 🧱 持久性 + 一致性       | 提供完整的逻辑操作记录，支持主从复制与数据恢复        |
| Relay Log（中继日志）     | 🚀 一致性             | 从库基于 relay log 重放主库操作，确保主从数据一致 |
| 错误日志（Error Log）     | ⚠️ 无直接对应（辅助）       | 辅助诊断异常，保证系统可靠运行                |
| 慢查询日志（Slow Log）     | 📊 无直接对应（优化）       | 用于性能分析与调优，间接帮助提高一致性与响应能力       |
| 通用查询日志（General Log） | 🕵️ 无直接对应（审计）      | 全部 SQL 活动记录，可用于调试和审计，不影响事务特性   |





## Redis





















## 操作系统




### 用户态和内核态

| 特性     | 用户态 (User Mode)                      | 内核态 (Kernel Mode)                       |
| ------------ | ------------------------------------------- | ---------------------------------------------- |
| 权限     | 低权限，不能直接访问硬件                    | 高权限，可执行所有CPU指令，直接操作硬件        |
| 执行代码 | 普通应用程序（如浏览器、文本编辑器）        | 操作系统内核（如进程调度、内存管理、设备驱动） |
| 系统调用 | 必须通过 系统调用（syscall） 进入内核态 | 可直接执行特权指令                             |
| 例子     | \`malloc()\`、\`printf()\`                      | \`fork()\`、\`read()\`、\`write()\`                  |

为什么需要区分？
- 安全性：防止用户程序直接操作硬件导致系统崩溃。
- 稳定性：内核管理关键资源（CPU、内存、设备），用户程序不能随意修改。

如何切换？
- 用户态 → 内核态：通过 系统调用 或 中断。
- 内核态 → 用户态：执行 \`iret\`（中断返回）或 \`sysret\`（系统调用返回）。

---

### 进程 vs. 线程
| 特性          | 进程（Process）                         | 线程（Thread）                     |
| ----------------- | ------------------------------------------- | -------------------------------------- |
| 定义          | 程序的 执行实例，拥有独立地址空间       | 轻量级进程，共享同一进程的地址空间 |
| 资源占用      | 高（独立内存、文件句柄、CPU时间片）         | 低（共享进程资源，仅私有栈和寄存器）   |
| 创建/销毁开销 | 高（需分配独立资源）                        | 低（共享进程资源）                     |
| 通信方式      | 进程间通信（IPC）：管道、消息队列、共享内存 | 直接读写共享变量、互斥锁、条件变量     |
| 崩溃影响      | 仅影响自身                                  | 可能影响同进程的其他线程               |
| 例子          | 浏览器、Word、游戏客户端                    | 浏览器标签页、Web服务器并发请求处理    |

为什么需要线程？
- 更轻量：创建/切换比进程快。
- 共享数据方便：无需IPC，可直接访问进程内存。
- 适合并发任务：如Web服务器同时处理多个请求。

---

###  进程间通信（IPC - Inter-Process Communication）
由于进程间 内存隔离，必须通过 IPC机制 通信：

| 方式                | 描述                                                     | 适用场景                       |
| ----------------------- | ------------------------------------------------------------ | ---------------------------------- |
| 管道（Pipe）        | 单向数据流，\`fd[0]\`读，\`fd[1]\`写（仅父子进程可用）           | Shell命令（如 \`ls \\| grep "txt"\`） |
| 命名管道（FIFO）    | 有名字的管道，允许无亲缘关系进程通信                         | 持久化进程通信                     |
| 消息队列            | 内核维护的链表，进程可发送/接收结构化消息                    | 异步通信（如日志系统）             |
| 共享内存            | 多个进程映射同一块物理内存，最快的IPC方式（无需内核介入） | 高性能数据交换（如数据库）         |
| 信号（Signal）      | 内核通知进程某事件发生（如 \`SIGKILL\`、\`SIGTERM\`）            | 进程控制（如 \`kill -9 PID\`）       |
| Socket              | 跨网络通信，也可用于本机进程（Unix Domain Socket更高效）     | 分布式系统（如Redis、Nginx）       |
| 信号量（Semaphore） | 同步机制，控制多个进程对共享资源的访问                       | 避免竞争条件（如多进程写文件）     |

###   线程间通信
| 方式                 | 描述                                                  | 适用场景               |
| ------------------------ | --------------------------------------------------------- | -------------------------- |
| 全局变量             | 最简单，但需加锁                                          | 少量数据共享               |
| 互斥锁（Mutex）      | 保证同一时间只有一个线程访问临界区                        | 保护共享资源（如计数器）   |
| 条件变量（Cond Var） | 让线程等待某个条件成立（常配合Mutex使用）                 | 生产者-消费者模型          |
| 信号量（Semaphore）  | 控制多个线程对资源的访问（比Mutex更灵活，可设置多个许可） | 限流（如数据库连接池）     |
| 读写锁（RW Lock）    | 读操作可并发，写操作独占                                  | 读多写少场景（如缓存）     |
| 原子操作（Atomic）   | CPU保证的不可中断操作（如 \`CAS\`）                         | 无锁编程（如高性能计数器） |

- 多进程：Chrome（每个标签页独立进程，崩溃不影响其他页面）。
- 多线程：Web服务器（Nginx、Redis 使用多线程处理并发请求）。







### 互斥锁、读写锁、自旋锁

| 特性           | 互斥锁 (Mutex)             | 自旋锁 (Spinlock)                  |
| -------------- | -------------------------- | ---------------------------------- |
| 阻塞机制   | 获取不到锁时线程休眠       | 获取不到锁时循环忙等待             |
| 实现方式   | 依赖操作系统调度           | 纯用户态原子操作实现               |
| 上下文切换 | 有（线程状态切换）         | 无                                 |
| CPU占用    | 等待时不占用CPU            | 等待时持续占用CPU                  |
| 适用场景   | 临界区较长或可能阻塞的操作 | 临界区极短（通常<CPU时间片）的操作 |
| 公平性     | 通常有等待队列保证公平     | 无公平性保证                       |
| 内存开销   | 较大（需维护线程状态）     | 极小（仅需一个原子变量）           |

#### 1. 获取锁的开销
- 互斥锁：
  - 系统调用开销（约100-200ns）
  - 线程状态切换（用户态→内核态→用户态）
  - 上下文保存与恢复
  
- 自旋锁：
  - 仅原子操作（约10-30ns）
  - 无模式切换
  - 无上下文保存

#### 2. 等待锁的开销
- 互斥锁：
  - 线程进入休眠状态（不占用CPU）
  - 唤醒时产生调度开销
  - 适合长时间等待（>线程切换时间）

- 自旋锁：
  - 持续占用CPU轮询
  - 无调度开销
  - 适合极短等待（<2次线程切换时间）







### 虚拟内存

#### 🧩 1. 虚拟内存的核心目标

- 让每个进程拥有独立完整的地址空间（看起来像有无限内存）
- 隔离性、安全性、跨平台一致性
- 支持进程间并发运行和懒加载机制

------

#### 🛠 2. 实现方式：页式虚拟内存 + 硬件支持

虚拟内存的实现依赖以下核心技术：

| 组件/机制                  | 功能说明                                                     |
| -------------------------- | ------------------------------------------------------------ |
| 页式管理（Paging）     | 把虚拟内存划分为固定大小的“页（Page）”，物理内存也划分为“页框（Frame）” |
| 页表（Page Table）     | 记录虚拟页 → 物理页框 的映射关系                             |
| MMU（内存管理单元）    | 硬件级地址翻译器，把虚拟地址翻译为物理地址                   |
| TLB（快表）            | 页表的缓存，加速地址转换                                     |
| 缺页中断（Page Fault） | 访问缺页时操作系统触发中断，决定是否从磁盘调入/创建新页等    |
| 交换空间（Swap）       | 暂存不常用内存页（换出页）到磁盘，节省物理内存               |

📦 进程访问虚拟地址 → MMU 查页表 → 找不到页 → 触发 Page Fault → OS 处理 → 加载页



| 管理方式 | 地址结构  | 分配方式   | 优势                 | 劣势                     | 应用系统                 |
| -------- | --------- | ---------- | -------------------- | ------------------------ | ------------------------ |
| 分页     | 单层页表  | 固定页大小 | 简洁高效，无外部碎片 | 页表可能大，缺页中断频繁 | Linux / Windows 主流方式 |
| 分段     | 段号+偏移 | 段独立分配 | 模块清晰、访问安全   | 外部碎片，管理复杂       | 老系统，教育用途         |
| 段页式   | 段+页     | 先段后页   | 结构清晰、空间高效   | 实现复杂                 | x86早期架构              |

------





### 线程池

- 构造函数：启动若干工作线程，每个线程循环等待任务。
- submit() 方法：外部调用，用于提交一个任务，放入队列，唤醒一个等待线程。
- 任务执行线程：每个线程从队列中拿任务并执行，队列为空则阻塞等待。
- 析构函数：设置停止标志，通知所有线程退出，然后逐个 join。







## 计网

### TCP的拥塞控制

| 名称         | 作用                       |
| ---------- | ------------------------ |
| \`cwnd\`     | 拥塞窗口（控制发送速率）             |
| \`ssthresh\` | 慢启动阈值（决定从指数增长转为线性增长的分界线） |
| \`rwnd\`     | 接收方通告的接收窗口               |
| \`RTT\`      | 往返时间，常用于判断网络延迟与是否丢包      |

### TCP 和UDP

UDP

适合实时性强、可容忍少量丢包的场景。

- 视频直播、语音通话（如VoIP）
- 在线游戏
- DNS 查询

| 特性     | TCP                        | UDP                     |
| -------- | -------------------------- | ----------------------- |
| 是否连接 | 面向连接（三次握手）       | 无连接                  |
| 可靠性   | 高（确认、重传、顺序控制） | 低（不保证）            |
| 速度     | 较慢（有额外控制）         | 较快（无连接和确认）    |
| 资源消耗 | 高（需要维护连接状态）     | 低（无状态）            |
| 应用示例 | HTTP、FTP、邮件            | DNS、视频通话、在线游戏 |

### TCP 三次握手

\`\`\`
客户端 (Client)                          服务器 (Server)
      |                                      |
      |  SYN=1, seq=x (SYN_SENT)             |
      | -----------------------------------### |
      |                                      |
      | SYN=1, ACK=1, seq=y, ack=x+1 (SYN_RCVD)
      | <----------------------------------- |
      |                                      |
      |  ACK=1, seq=x+1, ack=y+1 (ESTABLISHED)|
      | -----------------------------------### |
      |                                      |
      |                                (ESTABLISHED)
\`\`\`

1. 客户端发送 SYN=1   seq=x， 进入 SYN_SENT 状态。 
2. 服务器回复 SYN=1   ACK=1，ack=x+1,  seq=y，进入 SYN_RCVD 状态。 
3. 客户端发送 ACK=1   ack=y+   双方进入 ESTABLISHED状态。

为什么不是 2 次
- 若只有 2 次握手，服务器无法确认客户端是否收到自己的 SYN+ACK。  
- 如果客户端的 ACK丢失，服务器会一直等待（资源浪费），而客户端认为连接已建立，导致数据发送失败。

为什么不是 4 次？
- 冗余：第三次握手已确保双向通信可靠，无需额外确认。



### 四次挥手 

\`\`\`
客户端 (Client)                          服务器 (Server)
      |                                      |
      |  FIN=1, seq=u (FIN_WAIT_1)           |
      | -----------------------------------### |
      |                                      |
      |          ACK=1, ack=u+1 (CLOSE_WAIT) |
      | <----------------------------------- |
      |                                      |
      |                                (LAST_ACK)
      |          FIN=1, seq=v, ack=u+1       |
      | <----------------------------------- |
      |                                      |
      |  ACK=1, seq=u+1, ack=v+1 (TIME_WAIT) |
      | -----------------------------------### |
      |                                      |
      |                                (CLOSED)
\`\`\`
1. 客户端发送 FIN=1   seq=u，进入 FIN_WAIT_1 状态。 
2. 服务器回复 ACK=1   ack=u+1，进入 CLOSE_WAIT 状态（客户端收到后进入 FIN_WAIT_2）。 
3. 服务器发送 FIN=1   seq=v，进入 LAST_ACK 状态。 
4. 客户端回复 ACK=1   ack=v+1，进入 TIME_WAIT 状态（等待 2MSL 后关闭），服务器收到后立即关闭。

为什么需要四次？
- 全双工特性：TCP 连接是双向的，需分别关闭两个方向的数据流。 
  - 客户端主动关闭时，服务器可能还有数据要发送（第二次挥手仅确认，不立即关闭）。 
  - 服务器完成数据发送后，再单独关闭自己的方向（第三次挥手）。 

TIME_WAIT 状态的作用
- 确保最后一个 ACK 到达服务器
- 让网络中残留的旧报文失效（避免与新连接混淆）。









### HTTP 

HTTP (HyperText Transfer Protocol) 是用于分布式、协作式和超媒体信息系统的应用层协议。

1. 客户端建立TCP连接
2. 发送HTTP请求
3. 服务器处理请求并返回HTTP响应
4. 关闭TCP连接（在HTTP/1.0中）

HTTPS (HTTP Secure) 是HTTP的安全版本，通过SSL/TLS协议提供加密传输。

1. 客户端发起HTTPS连接请求
2. 服务器返回数字证书
3. 客户端验证证书
4. 双方协商加密算法和密钥（SSL/TLS握手）
5. 建立安全通道，开始加密通信

HTTP/1.1重要改进：较HTTP/1.0

- 持久连接：减少TCP连接建立/关闭的开销
- 管道化：允许在未收到响应时发送下一个请求
- 分块传输：允许服务器逐步发送数据
- 增强缓存控制：提供更精细的缓存策略
- 虚拟主机支持：通过Host头支持多个域名共享同一IP



### DNS





### NAT

- 数据包从内网到外网时，会转换源IP地址，由私网地址转换成公网地址。
- 数据包从外网到内网时，会转换目的IP地址，由公网地址转换成私网地址。



| 特性         | 静态 NAT                           | 动态 NAT                     |
| ------------ | ---------------------------------- | ---------------------------- |
| 映射关系 | 一对一固定映射                     | 多对一或多对多动态映射       |
| 配置方式 | 手动配置                           | 自动分配                     |
| IP 分配  | 每个内部地址有固定的外部地址       | 从地址池中动态分配外部地址   |
| 持久性   | 永久有效                           | 会话期间有效，超时后回收     |
| 适用场景 | 需要对外提供固定访问的服务         | 普通内部用户访问外部网络     |
| 安全性   | 较低（暴露固定映射）               | 较高（动态隐藏内部拓扑）     |
| 资源利用 | 效率低（每个内部主机需一个公网IP） | 效率高（多个主机共享公网IP） |
| 典型应用 | Web服务器、邮件服务器等            | 普通员工上网、移动设备访问等 |



### 网络协议

| ISO/OSI 七层模型 | TCP/IP 四层模型 | 主要协议示例                                             | 功能描述                 |
| -------------------- | ------------------- | ------------------------------------------------------------ | ---------------------------- |
| 7. 应用层        | 4. 应用层       | HTTP, HTTPS, FTP, SMTP, POP3, IMAP, DNS, DHCP, SNMP, SSH, Telnet, RDP, NFS | 提供用户接口和网络服务       |
| 6. 表示层        | (包含在应用层)      | SSL/TLS, JPEG, MPEG, ASCII, Unicode                          | 数据格式转换、加密/解密      |
| 5. 会话层        | (包含在应用层)      | NetBIOS, RPC, SIP, PPTP                                      | 建立/管理/终止会话           |
| 4. 传输层        | 3. 传输层       | TCP (可靠), UDP (不可靠)                                     | 端到端连接、流量控制、可靠性 |
| 3. 网络层        | 2. 网络层       | IP (IPv4/IPv6), ICMP, IGMP, ARP， NAT                        | 逻辑寻址、路由选择、分组转发 |
| 2. 数据链路层    | 1. 网络接口层   | Ethernet, WiFi (IEEE 802.11), PPP, MAC                       | 物理寻址、帧传输、错误检测   |
| 1. 物理层        | (包含在网络接口层)  |                                                              | 比特流传输、物理介质规范     |

---

### ARP

1. 解决映射问题
    在局域网（LAN）中，设备通信需要知道目标设备的 MAC地址（物理地址），但应用程序通常只知道 IP地址（逻辑地址）。ARP的作用就是通过IP地址查询对应的MAC地址。
2. 实现局域网内直接通信
    数据包在物理网络中传输时，最终依赖的是MAC地址（而非IP地址）。ARP确保IP数据包能被正确封装成以太网帧（或其他链路层协议帧）。









## 数据结构

### B+ 树和 B 树

| 特性           | B树                            | B+树                             |
| -------------- | ------------------------------ | -------------------------------- |
| 数据存储位置   | 所有节点都可能存储数据         | 只有叶子节点存储数据             |
| 叶子节点链接   | 无                             | 通过指针链接形成有序链表         |
| 非叶子节点结构 | 存储键和数据指针               | 只存储键和子节点指针             |
| 重复键值       | 不允许                         | 允许(非叶子节点键值会重复出现)   |
| 查询稳定性     | 不稳定(可能在内部节点找到数据) | 稳定(必须到叶子节点才能找到数据) |

为了减少到磁盘的读取次数，树高、读取的次数





### 满二叉树、 完全二叉树



### AVL 树 和 红黑树

| 特性          | AVL树                          | 红黑树                              |
| ------------- | ------------------------------ | ----------------------------------- |
| 平衡标准      | 严格平衡（左右子树高度差≤1）   | 弱平衡（最长路径不超过最短路径2倍） |
| 插入/删除效率 | 可能需要更多旋转操作来维持平衡 | 通常需要更少的旋转操作              |
| 查找效率      | 更优（因为更严格的平衡）       | 稍逊于AVL树                         |
| 适用场景      | 查询密集型应用                 | 插入/删除频繁的场景                 |





### 数组和链表的区别

- 数组：在内存中连续存储，大小固定（静态数组）或可动态调整（动态数组，但需要重新分配内存）。
- 链表：通过节点分散存储在内存中，每个节点包含数据和指向下一个节点的指针（单向链表）或前后节点的指针（双向链表），内存不要求连续。

| 特性   | 数组               | 链表         |
| ---------- | ---------------------- | ---------------- |
| 内存布局   | 连续                   | 非连续           |
| 访问方式   | 随机访问（O(1)）       | 顺序访问（O(n)） |
| 插入/删除  | O(n)（需移动元素）     | O(1)（已知位置） |
| 空间开销   | 无额外开销             | 需存储指针       |
| 大小调整   | 固定或昂贵（动态数组） | 灵活             |
| 缓存局部性 | 好                     | 差               |









## 实例



### 千万级请求的系统设计，例如铁路12306



\`\`\`
    ┌───────────────┐
    │   用户终端     │
    └──────┬────────┘
           │请求
    ┌──────▼────────┐
    │   CDN + LB    │  ← 缓存静态资源，分散流量
    └──────┬────────┘
           │请求
    ┌──────▼────────┐
    │    API网关     │  ← 鉴权、限流、路由
    └──────┬────────┘
   ┌───────────────┐
   │  微服务层      │
   │ ┌───────────┐ │
   │ │ 票务服务   │ │ ← 分布式锁、缓存热点余票
   │ ├───────────┤ │
   │ │ 订单服务   │ │ ← 事务、消息队列削峰
   │ ├───────────┤ │
   │ │ 用户服务   │ │
   │ └───────────┘ │
   └──────┬────────┘
          │读写
    ┌─────▼───────┐
    │ 分布式数据库  │ ← 分库分表，读写分离
    └─────┬───────┘
          │缓存同步
    ┌─────▼───────┐
    │   缓存层     │ ← Redis热点数据缓存
    └─────┬───────┘
          │异步消息
    ┌─────▼───────┐
    │  消息队列    │ ← Kafka/RabbitMQ 削峰填谷
    └─────────────┘
\`\`\`



CDN + 负载均衡（LB）：分散用户请求压力，缓存静态资源。

API 网关：做限流和鉴权，保护后端服务。

微服务层：

- 票务服务：用分布式锁保证票数准确，利用缓存优化查询。
- 订单服务：通过数据库事务和消息队列处理订单，防止超卖。
- 用户服务：用户认证和管理。

分布式数据库：水平拆分，提升并发处理能力。

缓存层：Redis缓存热点数据，快速响应。

消息队列：异步处理订单请求，削峰填谷。























































# 项目

## 编译器



### 1. 基础性

- 你实现的编译器支持哪些语法？比如是否支持嵌套语句、函数、数组等？
- 语法规则是你自己写的吗？有没有遇到 shift/reduce 冲突？怎么解决的？
- 你实现了哪些语义检查？比如类型检查、作用域检查有没有做？
- Flex 中你定义的词法规则长什么样？举个例子。
- 中间代码是什么形式？三地址码、抽象语法树，还是 LLVM IR？
- 目标代码是你自己定义的汇编格式吗？能举例一段你生成的汇编代码吗？

---

### RISC-V 整数寄存器一览表

| 寄存器 | ABI 名称 | 用途             | 保存责任 |
| ---------- | ------------ | -------------------- | ------------ |
| x1     | ra           | 返回地址             | Caller       |
| x2     | sp           | 栈指针               | Calle        |
| x10-11 | a0-a1        | 函数参数/返回值      | Caller       |
| x12-17 | a2-a7        | 函数参数             | Caller       |
| x18-27 | s2-s11       | 保存寄存器           | Callee       |
| x28-31 | t3-t6        | 临时寄存器           | Caller       |

---









## 桌面精灵



### 1. 基础

- 你是怎么实现窗口透明的？怎么做到不抢焦点但又能响应点击？
- 你用 Hook 拦截了哪些系统消息？鼠标？窗口？怎么实现的？
- 你使用 spine-unity 加载动画时，是否遇到过资源加载延迟的问题？怎么处理？
- 为什么需要协程？协程在 Unity 和线程的区别是什么？
- 如果我希望这个精灵能“回应用户说话”（比如通过语音合成），你准备怎么集成这个功能？









## QT

### 1.基础

- Qt 不太适合做游戏，为什么选择它？用了哪些 Qt 模块？
- 你的游戏是怎么处理界面更新和逻辑计算的？用定时器？还是事件驱动？
- 有没有设计“资源流转”的机制？比如原材料→加工→运输→成品？
- 你的类结构设计是怎样的？比如“建筑”、“物品”、“生产线”是怎么封装的？
- 存档功能怎么实现的？是序列化对象？用 JSON 还是其他格式？





















# 自我介绍



## HR

> 面试官你好，我是 XXX，目前是南京大学智能软件与工程学院的大三学生。
>
> 我将从技术背景、校园经历，个人优势三个方面来自我介绍。
>
> 
>
> 技术背景方面：
>
> 我的主要开发语言是 C++ 和 Python，也有使用过 Java 进行 UML 工具的课程项目开发。这学期一直保持力扣刷题，目前刷了 300 题。我学习的课程包括：操作系统、编译原理、软件系统设计、自动化测试、软件质量管理等。
>
> 
>
> 校园经历方面
>
> 大一时加入了校内的南播玩社团，参与策划和组织过“绿色生活打卡周”“益童筑梦”等活动，也有负责过活动推文的撰写与总结报告发布。参与过 RAG 检索问答系统的团队开发项目，完成了后端评估和登录系统部分，积累了团队协作和项目管理的实际经验。
>
> 
>
> 个人优势方面
>
> 我善于学习并应用新的知识。
>
> 比如自学 Unity、C#、游戏资源解包 等内容，从零完成了一个桌面精灵交互系统：包括 AB 包解包、Spine 动画接入、状态切换、协程管理等功能，也写了自动化脚本来优化资源处理流程。
>
> 
>
> 我也在尝试在 GitHub 上创建博客，整理学习内容和项目经验，提升表达能力（现在进度还没有多少）。
>
> 我能够很明显的感受到，进入大学的这几年我一直在成长，就比如去年在写一个登录页面的前后端实现的时候，总是有BUG，总是对接不上，然后其他事情的原因就放弃了，然后这学期，又尝试了一下，借助大模型，半小时就初步搭建了包括内网穿透、数据库搭建在网上的登录系统。
>
> 
>
> 我希望能在贵公司实习，进一步提升自己的能力。
>
> 谢谢！





## 技术



面试官你好，我是 XXX，目前是南京大学智能软件与工程学院的大三学生。

我将从技术背景、代码规范，个人优势三个方面来自我介绍。



技术背景方面：

我的主要开发语言是 C++ 和 Python，也有使用过 Java 进行 UML 工具的课程项目开发。这学期一直保持力扣刷题，目前刷了 300 题。我学习的课程包括：操作系统、编译原理、软件系统设计、自动化测试、软件质量管理等。



代码规范方面





个人优势方面

我善于学习并应用新的知识。

比如我曾经自学 Unity、C#、游戏资源解包 等内容，从零完成了一个桌面精灵交互系统：包括 AB 包解包、Spine 动画接入、状态切换、协程管理等功能，写了自动化脚本来优化资源处理流程。



我也在尝试在 GitHub 上创建博客，整理学习内容和项目经验，提升表达能力与技术沉淀（现在进度还没有多少）。

我能够很明显的感受到，进入大学的这几年我一直在成长，就比如去年在写一个登录页面的前后端实现的时候，总是有BUG，总是对接不上，然后其他事情的原因就放弃了，但是这学期，偶然间又想尝试了一下，借助大模型，半小时就初步搭建了包括内网穿透、数据库搭建在网上的登录系统。



我希望能在贵公司实习，进一步提升自己的能力。

谢谢！







# 面经







时间：30min

1. 介绍项目？背景？时间？分工？困难点？成果？
2. 项目的优点和缺点？
3. 合作冲突？
4. 如何了解和学习新知识？
5. 项目承担角色？
6. 项目中有和客户进行对接吗？
7. 何时感受到荣耀感？



1、学生表student。字段是name、age、class，统计每个班有多少人，并且按照每个班人数多少降序排列。
2、gdb调试 基本命令 怎么查看线程的工作状态。
3、linux系统的常用命令：（cd啥的就不用说了）。
4、java的自动装配原理。
5、数据库连接池的作用，数据库的脏读。
6、epoll等几种io复用的区别，epoll是怎么实现线程安全的，线程池是怎么实现的。
7、linux top命令是干什么的。
8、c++的智能指针，weak_ptr是怎么用的。



3.C++中多线程、多进程的通信
4.shared_ptr内部实现的机制
5.shared_ptr计数变量存放位置



1. 八股文类问题（高频）

- 内存管理：C内存分区（栈区寻址方式）、\`resize\`与\`reserve\`区别、\`vector\`与\`list\`底层实现。
- 面向对象：多态实现（虚函数机制、虚表指针）、纯虚函数与虚函数区别、基类析构函数为何需声明为虚函数。
- 语言特性：引用与指针的区别、\`const\`在拷贝构造函数中的作用、C++11新特性（\`auto\`、\`lambda\`、智能指针）。
- 智能指针：\`shared_ptr\`、\`unique_ptr\`、\`weak_ptr\`原理及使用场景。
- 并发与通信：进程间通信方式、线程同步方法。

2. 网络与操作系统

- 网络协议：TCP与UDP区别、HTTP与HTTPS区别、TCP报文结构及数据安全机制。
- 操作系统：32位与64位机器判断方法、\`xv6\`操作系统功能、Shell命令自定义实现。

3. 场景与设计

- 设计模式：单例模式的实现及线程安全问题。
- 调试能力：线上Bug定位方法（如日志分析、断点调试）。



------

#### 三、高频考点与趋势分析

1. 核心能力考察：
    - 底层原理：虚函数机制、内存管理、智能指针等是必考内容。
    - 实际应用：结合项目经验提问（如项目中的C++技术选型、性能优化）。
    - 代码健壮性：如拷贝构造函数的\`const\`必要性、\`vector\`动态扩容机制。
2. 延伸技能需求：
    - 网络编程：TCP传输细节（如300MB文件传输时间估算）。
    - 多线程开发：线程同步方式（互斥锁、信号量等）。

------

#### 四、面试流程与建议

1. 流程：
    - 技术面（1-2轮）：以八股文+项目深挖为主，部分涉及手撕代码。
    - HR面：职业规划、团队协作、抗压能力等软技能考察。
2. 建议：
    - 项目准备：重点梳理项目中C++相关模块，明确技术难点及解决方案。
    - 八股强化：针对虚函数、内存管理、STL容器等高频问题系统复习。
    - 模拟实战：通过\`sizeof\`与\`strlen\`区别等细节题查漏补缺。
`;export{n as default};
