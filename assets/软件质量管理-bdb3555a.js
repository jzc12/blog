import{o as t,c as p,a as i}from"./index-a44f82c6.js";const r="/blog/assets/scrum-framework-468ddcf3.png",n="/blog/assets/P-backlog-9b11ee8b.png",s="/blog/assets/estimate-87498f10.png",u="/blog/assets/燃尽图-4d0fe52f.png",e="/blog/assets/燃尽图2-733d1973.png",c="/blog/assets/change_cost-d48ea771.png",g="/blog/assets/XP_cost-133ffc66.png",h="/blog/assets/coding-4991024c.png",a="/blog/assets/yagni-b4288a5a.png",b="/blog/assets/kanban1-b07c5923.png",k={class:"markdown-body"},_="2025-06-10T00:00:00.000Z",P="2025-06-13T00:00:00.000Z",D="2025spring",f="软件质量管理复习",I={__name:"软件质量管理",setup(m,{expose:l}){return l({frontmatter:{date:"2025-06-10T00:00:00.000Z",updated:"2025-06-13T00:00:00.000Z",category:"2025spring",summary:"软件质量管理复习"}}),(S,o)=>(t(),p("div",k,o[0]||(o[0]=[i('<h2>Scrum</h2><h3>1.结构</h3><p><img src="'+r+'" alt="scrum-framework"></p><h3>2. “33355”</h3><ul><li>三大支柱：</li></ul><blockquote><p>透明：过程与工作成果对团队和利益相关者可见</p><p>检视：定期审查进展，识别偏差（通过5大事件实现</p><p>适应：根据检视结果进行调整、优化过程和产品方向</p></blockquote><ul><li>五个价值：</li></ul><blockquote><p>承诺</p><p>专注</p><p>开放</p><p>尊重</p><p>勇气</p></blockquote><ul><li>三个角色：</li></ul><blockquote><p>PO：负责最大化产品价值和开发团队的工作价值，管理产品Backlog</p><p>Scrum Master:按照Scrum 指南的规则建立Scrum ，服务Scrum Team、PO、组织;确保框架实施，移除障碍</p><p>开发人员:跨职能开发，交付可用增量</p></blockquote><ul><li>三个工件：</li></ul><blockquote><p>产品Backlog、Sprint Backlog、增量</p></blockquote><ul><li>五个事件</li></ul><blockquote><p>Sprint :固定周期（≤1个月），不可变更目标与质</p><p>Sprint 每日计划</p><p>每日Scrum 会议: 15分钟每日站会，调整当日计划</p><p>Sprint 评审会议: 展示增量，调整Backlog</p><p>Sprint 回顾会议: 改进流程与效能</p></blockquote><h3>3.需求——用户故事模板</h3><blockquote><p>作为 &lt; &gt; ——用户画像</p><p>我想 &lt; &gt; ——预期功能</p><p>从而 &lt; &gt; ——为什么用户想要这个功能</p></blockquote><h3>4.Ron Jeffries 的 3C 原则</h3><blockquote><p>卡片：在一堆卡片上写下期望的软件特性</p><p>交谈：聚在一起对要开发的软件进行深入讨论</p><p>确认：对完工条件进行确认</p></blockquote><ul><li>DOD （完成的定义） ——Definition of Done</li><li>BDD (行为驱动开发) ——Behavior-Driven Development <ul><li>核心思想是通过定义软件的行为来驱动开发过程</li><li>重点是增强团队对需求的理解，并确保开发的软件满足业务目标</li><li>强调在开发开始之前，用自然语言描述软件应如何行为</li></ul></li></ul><h3>5. 用户故事 INVEST原则</h3><blockquote><p>独立性</p><p>可协商性</p><p>有价值</p><p>可以估算性</p><p>短小</p><p>可测试性</p><p>每个用户故事都有应该像标准的快递箱——独立封装、地址清晰、体积适中、明确、可追踪、允许改派等</p></blockquote><h3>6. 用户故事SMART原则</h3><blockquote><p>S——Specific(具体)</p><p>M——Measurable(可衡量)：用户故事的结果必须能用明确的指标或验收标准验证</p><p>A——Achievable(可实现)</p><p>R——Relevant(相关性)：用户故事与当前项目或者用户需求相关</p><p>T——Time-bound(有时限)：明确截至时间或者优先级</p></blockquote><h3>7.产品Backlog</h3><ul><li>产品 Backlog 是Scrum 的核心，按照重要性排序的需求或者故事的分列表</li></ul><img src="'+n+'" alt="P-backlog" style="zoom:75%;"><h3>8.Product Backlog（动态需求池）</h3><blockquote><p>是一份涌现的和有序的清单，它列出了改进产品所需的内容。它是 Scrum Team 所承担工作的唯一来源。</p></blockquote><h3>9.用户故事地图</h3><h3>10.Sprint</h3><ul><li>是 Scrum 的核心，在这里创意（idea）转化为价值。</li><li>固定时长的事件，为期一个月或更短，以保持一致性。前一个 Sprint 结束后，下一个新的Sprint 紧接着立即开始 <ul><li>时间短：“敏捷”，短反馈周期=频繁交付=频繁客户反馈=错误方向=持续时间短=学习改进速度快</li><li>时间长：更多时间作充分准备、解决问题、达成目标，不会被接二连三的会议压的不堪重负</li><li>当前，Scrum 周期通常为2个星期</li></ul></li><li>Sprint计划会议目标</li></ul><blockquote><p>sprint目标、团队成员名单、Sprint backlog、确定好sprint演示日期、确定好时间地点,供举行每日scrum会议</p></blockquote><h3>11.估算</h3><img src="'+s+'" alt="estimate" style="zoom:30%;"><blockquote><p>据收益递减原理，不应在估算上花太多的时间。可以做出一个快速但不那么准确的估计，也可以再多花一点时间做一个更准确的估计</p></blockquote><h4>估算单位(story point)</h4><ul><li>计划扑克</li><li>卡片队列估算法</li></ul><h4>故事与任务</h4><p>Story是可以交付的东西，Task是不可以交付的，Product Owner对Task不关心</p><table><thead><tr><th><strong>Scrum工件</strong></th><th><strong>定义</strong></th><th><strong>对应的承诺</strong></th></tr></thead><tbody><tr><td>Product Backlog</td><td>产品需求动态清单</td><td>Product Goal（产品愿景）</td></tr><tr><td>Sprint Backlog</td><td>Sprint任务计划（目标+选定的条目）</td><td>Sprint Goal（迭代目标）</td></tr><tr><td>Increment</td><td>符合完成标准的可交付成果</td><td>Definition of Done（完成标准）</td></tr></tbody></table><h3>12.燃尽图</h3><img src="'+u+'" alt="燃尽图" style="zoom:50%;"><img src="'+e+'" alt="燃尽图2" style="zoom:75%;"><h3>13.Scrum 优势与局限</h3><blockquote><p>轻量灵活：仅定义必要规则，兼容多种实践</p><p>持续改进：通过事件循环实现经验反馈</p><p>价值驱动：以Product Goal为导向，确保交付有效性</p><p>协作透明：跨角色协作，信息共享最大化</p></blockquote><blockquote><p>没有技术实践</p><p>可以使用极限编程技术实践：测试驱动开发、简单设计、重构、持续集成等等</p></blockquote><h2>XP</h2><blockquote><p>Extreme Programming 这一名称体现了其核心理念：把有益的实践做到极致</p></blockquote><h3>1.XP的核心——开发阶段</h3><blockquote><p>编写代码、运行所有测试用例、迭代测试用例和代码、如果需要，进行重构、集成（包括测试）</p></blockquote><p><strong>说明</strong>：</p><ul><li>结对编程</li><li>测试驱动</li><li>让测试用例运行起来、为系统的分析、设计、实现和测试增加价值</li><li>开发后立即进行集成，包括集成测试</li></ul><h3>2.变更成本曲线</h3><img src="'+c+'" alt="change_cost" style="zoom:75%;"><p><strong>降低变更成本的技术</strong></p><ul><li>OOP</li><li>自动化测试</li><li>重构技术</li><li>CICD：鼓励频繁交付和持续部署</li><li>Beck的曲线并非无视规律，只是把反馈周期从几个月缩短到几分钟，结果就没有机会让成本成指数增长</li><li>平坦曲线的前提是严格执行XP实践</li></ul><p><strong>目标</strong></p><p><img src="'+g+'" alt="XP_cost"></p><h3>3.价值观</h3><h4>交流</h4><blockquote><p>开发者 – 开发者</p><p>开发者 – 客户</p><p>开发则 – 管理层</p></blockquote><p>XP强制要求的沟通方式</p><blockquote><p>单元测试、结对编程、任务估算</p></blockquote><h4>简单</h4><h4>反馈</h4><ul><li>即使反馈 <ul><li>程序员：单元测试</li><li>客户：实时估算</li><li>团队：进度跟踪反馈</li></ul></li><li>中长期反馈 <ul><li>客户：功能测试</li><li>运行软件测试</li></ul></li></ul><h4>勇气</h4><p>以前三个价值观支持</p><h3>4.软件开发的基本内容</h3><img src="'+h+'" alt="coding" style="zoom:30%;"><h4>测试</h4><ul><li>长期来看：测试被运行和维护的前提，让程序运行寿命更长</li><li>短期来看：信心</li><li>类型 <ul><li>单元测试</li><li>客户编写的功能测试？？？？</li></ul></li></ul><h4>倾听</h4><blockquote><p>程序员与业务人员交流、相互之间</p><p>业务人员说明项目的需求、程序员帮助业务人员了解哪些容易、哪些困难</p></blockquote><h4>设计</h4><blockquote><p>低耦合：良好的设计会组织逻辑，以便系统的一部分发生变化并不总是需要系统的另一部分发生变化。</p><p>封装：良好的设计将逻辑放在它所操作的数据附近。</p><p>可扩展性：良好的设计允许系统扩展，且仅在一个地方进行更改。</p></blockquote><h3>5.基本实践</h3><h4>5.1 计划游戏</h4><h4>5.2 小发布</h4><h4>5.3 隐喻</h4><h4>5.4 简单设计</h4><h4>5.5 测试TDD</h4><h4>5.6 重构 Refactoring</h4><h4>5.7 结对编程</h4><h4>5.8 代码集体拥有制</h4><h4>5.9 CICD</h4><h4>5.10 40小时工作制</h4><h4>5.11 现场客户</h4><h4>5.12 编码标准</h4><h4>XP做法可行性</h4><h3>6.TDD</h3><p><strong>测试</strong></p><blockquote><ol><li><p>测试是独立且自动的</p></li><li><p>测试应当有价值</p></li></ol></blockquote><h4>6.1 程序员测试</h4><h4>6.2 客户测试</h4><h4>6.3 其他测试</h4><blockquote><p>并行测试：新系统的运行与旧系统完全一致</p><p>压力测试：模拟可能出现的最恶劣负载情况的测试</p><p>随机测试：确保系统自面对无意义输入时能合理响应的测试</p></blockquote><h4>6.4 TDD</h4><p><strong>先写测试再写实现</strong></p><blockquote><p>三阶段循环： 红（失败测试） –&gt; 绿（通过实现） –&gt; 重构（优化代码）</p></blockquote><p><strong>目标</strong>：创建可测试、可维护、最小化的代码</p><p><strong>标准流程</strong></p><blockquote><ol><li>编写失败测试</li><li>快速实现通过</li><li>逐步泛化</li><li>持续重构</li></ol></blockquote><p><strong>核心价值</strong></p><blockquote><p>缺陷预防、设计引导、降低耦合、活的文档</p></blockquote><h3>7. 简单设计的四大准则</h3><blockquote><p>通过所有测试、消除重复、清晰表达意图、最小化元素数量</p></blockquote><p><strong>YAGNI</strong>原则的经济学</p><p><img src="'+a+'" alt="yagni"></p><p><strong>边际成本陷阱</strong></p><blockquote><p>假设开发某功能的当前成本为 $C $</p><p>若提前$N$个周期开发： 总成本 = $ C × (1 + 维护率)^N $</p><p>而实际需求出现时的成本可能仅为$C×0.7$（技术演进）</p></blockquote><p><strong>重构的纪律性</strong></p><blockquote><p>技术 ： 提升可读性、降低维护成本、支持演化式设计</p></blockquote><blockquote><p>工具 ： IDE自动化重构、测试框架、代码质量扫描</p></blockquote><ul><li>重构不是推到重写，而是让代码随时间越变越优雅的持续艺术</li></ul><h4>XP设计</h4><blockquote><p>降低流程中的不可逆性来应对复杂性</p><p>持续保持代码清晰简洁的渴望</p><p>通过重构自信改进代码的能力</p><p>精通模式：不仅理解解决方案，更懂应用时机与演进路径</p><p>预见变化的眼光：知晓今日决策终将改变</p><p>运用代码、图表及最重要的——对话，向相关人员传达设计</p></blockquote><h3>8.持续集成</h3><blockquote><p>持续集成 (Continuous Integration, CI) 是一种软件开发实践，团队成员频繁地（通常每天至少一次）将代码更改集成到共享的代码库主线中。</p></blockquote><h4>8.1 传统集成的特点</h4><ul><li>一个开发者可能对代码库的某个部分做了修改，而另一个开发者基于旧版本的代码进行了开发。</li><li>当这些更改最终汇合时，可能会出现微妙且难以调试的错误。</li><li>开发者：导致尽量减少与其他部分的交互，但这往往会导致技术债的积累和代码质量的下降。</li><li>代码质量和重构 <ul><li>开发者可能会避免进行重要的代码重构</li><li>意识到代码结构存在问题，或者需要清理重复代码，他们也可能因为担心引入集成冲突而选择维持现状</li><li>重构的回避，阻止了代码库根据需求变化和经验积累进行健康的演进</li></ul></li></ul><h4>8.2 CI 的解决方案</h4><blockquote><p>核心理念：持续集成旨在消除传统集成的痛苦</p><p>核心思想：让团队成员非常频繁地集成他们的工作，通常是每天多次</p><p>每次集成涉及的代码量都相对较小，从而显著降低了合并冲突的可能性和复杂性</p><p>快速反馈：任何集成引入的问题都能够被自动化构建和测试快速发现</p><p>CI 鼓励使用主线开发</p></blockquote><h4>8.3 CI 实践示例</h4><ul><li>获取最新代码： 确保本地环境与中央仓库同步是 CI 的基本前提</li><li>本地构建与开发：本地环境中运行完整的自动化构建脚本，包括编译代码和运行所有的自动化测试</li><li>集成前检查：推送（Push）之前，必须再次执行 git pull， 将这些最新的更改合并（Merge）到本地工作副本中，合并后我必须再次在本地运行完整的自动化构建。</li><li>本地构建通过与推送</li></ul><h4>8.4 持续集成的好处</h4><ul><li>降低风险</li></ul><blockquote><p>减少集成风险、快速发现错误、更容易定位错误、减少集成地狱</p></blockquote><ul><li>促进改进与发布</li></ul><blockquote><p>鼓励并支持重构、提高代码质量、更频繁可靠的发布、发布成为业务决策</p></blockquote><h4>CI &amp; CD(Continuous Deployment)</h4><blockquote><p>CI 主要发生在开发环境中、CD是CI的自然延伸，CI是实现CD 的必要前提。</p></blockquote><h2>Kanban</h2><h3>定义</h3><blockquote><p>Kanban 是⼀种优化价值流动 (the flow of value) 的策略，其过程使⽤可视化与拉 式系统</p><p>Kanban 包括以下三个协同⼯作的实践：</p><ul><li>定义与可视化⼯作流</li><li>主动管理⼯作流中的⼯作项 (item)</li><li>改进⼯作流</li></ul></blockquote><blockquote><p>Kanban已被普遍视为与Scrum、XP等并列的重要敏捷实践框架</p><p>运维、持续交付等场景倾向用Kanban；新产品开发常用Scrum</p></blockquote><p><img src="'+b+'" alt="kanban1"></p><h3>可视化工作流</h3><blockquote><p>Kanban 系统成员对于流 的明确且共同的认知，就称为 “⼯作流的定义” (Definition of Workflow，DoW)</p></blockquote><h3>WIP</h3><blockquote><p>Kanban 系统成员须明确地控制在⼯作流中从开始到结束间的⼯作项数量。这种控制称为 “WIP 数量限制”</p></blockquote><blockquote><p>控制 WIP 不仅能够有助于⼯作流，也能够改进 Kanban 系统成员共同的专注、承诺及协作。任何在控制 WIP 时可接受的例外情况都应该作为 DoW 的⼀部分予以 明确说明。</p></blockquote><h3>Kanban 度量</h3><ul><li>WIP：已开始但未完成的⼯作项的数量。</li><li>产能 (Throughput)：每单位时间内完成的⼯作项的数量。 请注意，产能的 度量是对⼯作项的精确计数。</li><li>⼯作项存续时⻓ (Work Item Age)：⼀⼯作项从开始到当前时刻之间所经过 的时间⻓度。</li><li>周期时间 (Cycle time)：⼀⼯作项从开始到完成之间所经过的时间⻓度。</li></ul><h3>Kanban &amp; Scrum</h3><h4>差异</h4><ol><li>框架本质与节奏：</li></ol><ul><li>Scrum: 迭代式 (Iterative)。工作被划分为固定时长（通常2-4周）的<strong>Sprint（冲刺）</strong>。每个Sprint开始时计划需要完成的工作（增量），并在Sprint结束时交付。强制固定节奏（如每日站会、Sprint评审、回顾等）。<strong>优点：</strong> 节奏明确，提供计划性和稳定性，适合有明确交付目标的项目。<strong>限制：</strong> Sprint中<strong>通常拒绝范围变更</strong>。</li><li>Kanban: 流动式 (Flow-based)。没有固定的迭代周期或时间盒限制。工作项从“待办”队列中<strong>持续流动</strong>，完成后拉取下一个高优先级的项。实现<strong>连续交付</strong>。<strong>优点：</strong> 对需求变更反应<strong>极其灵活</strong>，新任务可随时加入队列。<strong>注意：</strong> 团队需<strong>自行建立</strong>回顾、优化等节奏。</li></ul><ol start="2"><li>角色与职责：</li></ol><ul><li>Scrum:规定三个明确角色： <ul><li><strong>产品负责人 (PO):</strong> 最大化产品价值，管理产品待办列表。</li><li><strong>Scrum Master (SM):</strong> 确保团队遵循Scrum流程，移除障碍。</li><li><strong>开发团队：</strong> 跨职能、自组织，负责交付Sprint目标内的增量。<strong>优点：</strong> 职责分工清晰。</li></ul></li><li>Kanban:不指定强制角色。通常保留团队现有组织架构，成员根据职责各司其职（如服务交付经理、服务请求经理等角色是可选项，<strong>非强制</strong>）。<strong>优点：</strong> <strong>灵活性高</strong>，鼓励团队成员<strong>自行协作分配</strong>工作。</li></ul><ol start="3"><li>时间规划与变更处理：</li></ol><ul><li>Scrum: Sprint作为核心时间盒进行计划、评估和交付。<strong>固定节奏会议</strong>（Sprint规划、每日站会、Sprint评审、Sprint回顾）是框架核心。在Sprint进行中，<strong>原则不接受新需求变更</strong>（除非极其特殊情况）。</li><li><strong>Kanban:</strong> <strong>没有时间盒约束</strong>，计划、交付<strong>持续进行</strong>。<strong>需求变更可随时反映</strong>在待办事项队列中，团队根据当前优先级从队列中<strong>拉取</strong>工作。这使其在<strong>处理变更方面异常灵活</strong>。</li></ul><ol start="4"><li>流程、事件与工件：</li></ol><ul><li>Scrum:强调规定的活动（事件）和产出（工件）： <ul><li><strong>事件：</strong> Sprint规划会、每日站会、Sprint评审会、Sprint回顾会。</li><li><strong>工件：</strong> 产品待办列表、Sprint待办列表、增量。<strong>优点：</strong> <strong>提供高度结构化的流程模板</strong>。</li></ul></li><li>Kanban:没有指定强制性的事件或工件 <ul><li>唯一核心工件是看板及相关可视化策略。</li><li>虽鼓励<strong>反馈环</strong>（如运营评审），但频率、形式完全由团队决定。<strong>优点：</strong> <strong>提供灵活的工具箱</strong>，团队按需采用实践，适应性强。</li></ul></li></ul><p>关键</p><ul><li><strong>Scrum：</strong> 更倾向于提供<strong>结构化的框架和纪律</strong>，强调固定的周期、明确的角色和清晰的事件，为团队提供可预测的节奏，但牺牲了对范围变更的即时响应。</li><li><strong>Kanban：</strong> 更侧重于<strong>流程可视化和限制在制品 (WIP)</strong>，核心价值是<strong>最大化流动和响应变化</strong>。它提供了一套灵活的实践工具，对角色、会议、时间节奏要求极低，但要求团队具备更强的自我管理和持续改进能力。</li></ul><h2>DevOps</h2><h2>敏捷</h2>',158)])))}};export{D as category,_ as date,I as default,f as summary,P as updated};
