const n=`---
date: 2025-06-10
updated: 2025-06-14
category: 2025spring
summary: 软件系统设计期末复习
---

## OOP

### 面向对象的设计原则

> 可维护性、可复用性、重构

### 单一职责原则

### 开闭原则

### 里氏代换原则

### 依赖倒转原则

### 接口隔离原则

### 合成复用原则

### 迪米特法则



## 设计模式



### 简单工厂模式

> 当加入新的产品时，违背了开闭原则

\`\`\`python
class SimpleFactory {
    public Product createProduct(String type) {
        if (type.equals("A")) return new ProductA();
        else if (type.equals("B")) return new ProductB();
        return null;
    }
}
\`\`\`

### 工厂方法模式

\`\`\`python
interface Factory {
    Product createProduct();
}
class FactoryA implements Factory {
    public Product createProduct() { return new ProductA(); }
}
class FactoryB implements Factory {
    public Product createProduct() { return new ProductB(); }
}
\`\`\`

### 抽象工厂模式

\`\`\`	python
// 轮胎接口
interface Tire {
    void inflate();
}

// 引擎接口
interface Engine {
    void start();
}

// 奔驰轮胎
class BenzTire implements Tire {
    public void inflate() { System.out.println("奔驰轮胎充气"); }
}

// 奔驰引擎
class BenzEngine implements Engine {
    public void start() { System.out.println("奔驰引擎启动"); }
}

// 宝马轮胎
class BmwTire implements Tire {
    public void inflate() { System.out.println("宝马轮胎充气"); }
}

// 宝马引擎
class BmwEngine implements Engine {
    public void start() { System.out.println("宝马引擎启动"); }
}
\`\`\`





### 状态模式（State Pattern）

例如电梯状态：停止、运行、暂停，每种状态下“按按钮”行为不同。

#### 类结构图（简略）：

\`\`\`
Context（上下文）
└── State（抽象状态类）
    ├── ConcreteStateA
    └── ConcreteStateB
\`\`\`

#### C++ 示例：

\`\`\`cpp
class State {
public:
    virtual void handle() = 0;
};

class ConcreteStateA : public State {
public:
    void handle() override {
        std::cout << "State A: Doing A's logic\\n";
    }
};

class ConcreteStateB : public State {
public:
    void handle() override {
        std::cout << "State B: Doing B's logic\\n";
    }
};

class Context {
    State* state;
public:
    void setState(State* s) { state = s; }
    void request() { state->handle(); }
};
\`\`\`

------

### 命令模式（Command Pattern）


将“命令”封装为对象，支持撤销、重做、队列、日志等操作。


遥控器上的“命令按钮”，每个按钮其实封装了一个命令对象。

#### 类结构：

\`\`\`
Invoker（调用者） --> Command（抽象命令） --> Receiver（实际执行者）
\`\`\`

#### C++ 示例：

\`\`\`cpp
class Command {
public:
    virtual void execute() = 0;
};

class Light {
public:
    void on() { std::cout << "Light is ON\\n"; }
};

class LightOnCommand : public Command {
    Light* light;
public:
    LightOnCommand(Light* l) : light(l) {}
    void execute() override { light->on(); }
};

class Remote {
    Command* command;
public:
    void setCommand(Command* c) { command = c; }
    void pressButton() { command->execute(); }
};
\`\`\`

------

### 适配器模式（Adapter Pattern）


把一个类的接口“适配”成客户端期望的形式，解决接口不兼容问题。


用“三相插头适配器”连接国外电器。

#### 类结构：

\`\`\`
Client --> Target（目标接口）
                   ↑
             Adapter（适配器）-- Adaptee（被适配的类）
\`\`\`

#### C++ 示例：

\`\`\`cpp
class Target {
public:
    virtual void request() = 0;
};

class Adaptee {
public:
    void specificRequest() { std::cout << "SpecificRequest\\n"; }
};

class Adapter : public Target {
    Adaptee* adaptee;
public:
    Adapter(Adaptee* a) : adaptee(a) {}
    void request() override { adaptee->specificRequest(); }
};
\`\`\`

------

### 组合模式（Composite Pattern）


将对象组合成树状结构，让客户对单个对象和组合对象“统一处理”。

文件夹和文件是一样的接口，都可以被“打开”。

####  类结构：

\`\`\`
Component（抽象组件）
├── Leaf（叶子节点）
└── Composite（组合节点） --> 维护 Component 的集合
\`\`\`

####  C++ 示例：

\`\`\`cpp
class Component {
public:
    virtual void operation() = 0;
    virtual void add(Component*) {}
};

class Leaf : public Component {
public:
    void operation() override {
        std::cout << "Leaf\\n";
    }
};

class Composite : public Component {
    std::vector<Component*> children;
public:
    void add(Component* c) override { children.push_back(c); }
    void operation() override {
        std::cout << "Composite:\\n";
        for (auto c : children) c->operation();
    }
};
\`\`\`

------

###  单例模式（Singleton Pattern）


保证一个类只有一个实例，并提供一个访问它的全局入口。

####  类比：

操作系统里的“任务管理器”——系统全局只有一个。

####  C++ 示例：

\`\`\`cpp
class Singleton {
private:
    Singleton() {}
public:
    static Singleton& getInstance() {
        static Singleton instance; // C++11 线程安全
        return instance;
    }

    void say() {
        std::cout << "I'm Singleton!\\n";
    }

    // 禁用拷贝和赋值
    Singleton(const Singleton&) = delete;
    void operator=(const Singleton&) = delete;
};
\`\`\`





### 观察者模式

"被观察者（Subject）状态变化时，自动通知所有观察者（Observer）。"


 举个栗子 🌰：

\`\`\`java
// 1. 群主（被观察者）
class WeChatGroup {
    private List<Member> members = new ArrayList<>();

    public void addMember(Member m) { members.add(m); }
    public void sendMsg(String msg) {
        for (Member m : members) {
            m.receive(msg); // 群发消息
        }
    }
}

// 2. 群成员（观察者）
class Member {
    public void receive(String msg) {
        System.out.println("收到消息: " + msg);
    }
}

// 3. 使用
WeChatGroup group = new WeChatGroup();
group.addMember(new Member());
group.addMember(new Member());
group.sendMsg("今晚聚餐！"); // 所有人自动收到
\`\`\`

---

 关键点：

- 被观察者：维护观察者列表，提供 \`添加/删除/通知\` 方法。
- 观察者：实现一个接收通知的方法（如 \`update\` 或 \`receive\`）。
- 自动通知：被观察者变化时，一键通知所有观察者。

---

适用场景：

- 微信/QQ 群消息
- 天气预报更新
- 游戏里的成就系统（达成条件时自动触发）
- MVC 系统



### 总结

| **分类**   | **解决的核心问题**      | **典型模式举例**     | **核心关键词** |
| :--------- | :---------------------- | :------------------- | :------------- |
| **创建型** | 如何更灵活地创建对象？  | 单例、工厂、建造者   | **实例化控制** |
| **结构型** | 如何组织类/对象的结构？ | 适配器、装饰器、代理 | **组合扩展**   |
| **行为型** | 对象间如何高效协作？    | 观察者、策略、责任链 | **交互解耦**   |





## SysArch

---

### 架构设计



#### 1. 软件架构的定义

- 本质：系统的一种或多种结构（structures）
- 构成要素：
    - 软件元素（software elements）
    - 元素的外部可见属性（externally visible properties）
    - 元素间的关系（relationship）
- 关键说明：
    - 架构不仅是框线图（box-and-line drawings），而是包含组件行为（behaviour of components）
    - 框线图仅是设计起点，非完整架构



#### 2. 架构的核心作用

2.1 需求实现的决策载体

- 体现早期设计决策（early design decisions），尤其是最难变更（hardest to change）的部分
- 是需求如何落地的首次具体化

2.2 产品线工程的关键

- 支撑高效开发相似系统家族（product line engineering），降低重复成本与风险

2.3 系统理解的入口

- 新成员介入系统的首要检查对象

2.4 维护与修改的框架

- 为变更决策提供参考框架（framework of reference）



#### 3. 软件架构的重要性

3.1 沟通与协作的载体

- 统一沟通语言：协调用户需求、进度、成本和管理决策
- 利益平衡框架：识别并协商冲突目标（如性能 vs. 成本）

3.2 组织与流程的基石

- 定义开发结构：
    - 团队分工依据
    - 预算规划单元
    - 工作分解结构（WBS）基础
- 支撑工程活动：
    - 文档/配置管理（CM libraries）的组织框架
    - 集成、测试计划与维护的基准

3.3 质量属性的决定性因素

- 影响关键质量：可修改性（modifiability）、安全性（security）、可用性（usability）
- 变更管理工具：
    - 局部变更（Local）：单组件修改
    - 非局部变更（Non-local）：多组件协同修改
    - 架构变更（Architectural）：系统基础结构与通信机制调整
- 警示：80%系统工作量在部署后维护（post-deployment effort）

4. 复用与集成的核心

- 可转移的抽象：一对多映射（one-to-many mapping），单一架构支撑多系统
- 产品线共享基础：全产品线复用同一架构（basis for product commonality）
- 组件化开发：通过架构集成独立组件（CBSE - Component-Based Software Engineering）



#### 4. 架构的全局价值总结

| 维度     | 核心贡献                                                     |
| -------- | ------------------------------------------------------------ |
| 战略决策 | 固化关键设计选择，降低后期变更成本                           |
| 技术管理 | 为团队分工、测试、集成、维护提供结构化框架                   |
| 质量保障 | 直接制约可修改性/安全性等非功能属性（注：可实现但无法完全保证） |
| 经济效率 | 通过复用（产品线/CBSE）大幅降低开发成本与风险                |



---

### 功能需求：

| 对比维度     | 功能需求（Functional Requirements） | 功能（Functionality）                      |
| ---------------- | --------------------------------------- | ---------------------------------------------- |
| 关注点       | 行为规范（系统必须做什么）          | 能力体现（系统能否完成任务）               |
| 与结构的关系 | 隐含对行为的要求，不直接约束结构        | 完全独立于结构（同一功能可用不同架构实现） |
| 抽象层级     | 需求层（描述“目标”）                    | 设计层（描述“能力”）                           |
| 示例         | “系统应在1秒内响应用户请求”             | “系统支持秒级响应”                             |

> 关键结论：
>
> - 功能需求定义系统行为的规则和约束，而功能是系统实现这些行为的内在能力。
> - 功能作为能力的抽象，是架构设计中的常量，而功能需求是架构设计的输入约束。

---

### 质量需求：

> 质量要求 = 系统的期望特性（质量属性）

- 是功能性需求之外，系统必须提供的额外特性（desirable characteristics *on the top of* functional requirements）。
    - 性能（每秒处理10,000请求）
    - 安全性（抵御SQL注入攻击）
    - 可维护性（修改代码不超过2小时）

 功能性 VS 质量性

| 类型     | 功能需求（Functional Requirements） | 质量要求（Quality Requirements）                             |
| ------------ | ----------------------------------- | ------------------------------------------------------------ |
| 目标     | 系统“做什么”                        | 系统“做得如何”（性能、安全、成本等）                         |
| 作用对象 | 直接描述行为                        | 限定功能需求 或 限定整体产品                         |
| 案例     | “用户可提交订单”                    | “订单提交响应时间≤0.5秒”（限定功能需求）<br>“系统全年故障率<0.1%”（限定整体产品） |

质量属性决定功能分配的约束

> “若质量属性重要 → 软件架构强制约束功能在结构上的映射”

- 功能分配灵活性：若无重要质量要求，同一功能可自由分配至任意结构（如模块、服务、层）。
- 质量属性的约束力：若存在关键质量需求（如高性能、高安全），架构设计必须限制功能的分配路径。

 

典型场景

| 质量属性 | 对功能分配的约束案例     | 架构决策示例                                   |
| ------------ | ---------------------------- | -------------------------------------------------- |
| 性能     | 高频交易功能不得跨越网络边界 | 将交易功能与数据库部署在同一服务器（避免网络延迟） |
| 安全性   | 用户认证功能需独立于其他模块 | 设计独立的认证微服务（隔离敏感操作）               |
| 可维护性 | 结算逻辑需集中管理           | 封装结算功能为单一模块（降低修改影响范围）         |

---

### 约束

> 1. 约束是自由度为零的设计决策” (A constraint is a design decision with ZERO degrees of freedom)

- 设计决策完全不可调整、无妥协或变通空间

> 2. 约束是预先确定且已固化的设计决策

- 约束通常来自外部强制要求或前期不可逆决策（如协议兼容性）。
- 案例：银行系统必须符合PCI-DSS安全标准（外部约束）；项目必须兼容旧版API

> 3. 通过接受决策并协调受影响的设计决策来满足约束

- 承认约束的不可变性，停止尝试修改或规避
- 调整其他关联设计，使整体架构与约束兼容。

![约束](./../../public/assets/约束.png)



---

### 质量属性（Quality Attributes）

#### 1. 本质与定位

- 不可附加性：质量属性不是开发完成后“添加”的功能，而是贯穿软件全生命周期的内在基因。
- 业务驱动性：源于业务目标，需在所有开发阶段持续关注。
- 超越功能性：是功能需求的增强维度，决定系统“做得多好”。

#### 2. 质量失败的代价

> “系统常因质量缺失（如难以维护、移植）而被迫重构”

- 功能优先的开发模式（*Functionality takes front seat*）易忽视质量，导致后期成本剧增（*redesigned*）。

| 类别             | 观测时机         | 代表属性                               | 核心问题                     |
| ---------------- | ---------------- | -------------------------------------- | ---------------------------- |
| 可观测质量属性   | 运行时（外部）   | 性能、安全、可用性、易用性             | 系统行为需求满足度？         |
| 不可观测质量属性 | 非运行时（内部） | 可修改性、可移植性、可重用性、可测试性 | 系统维护/扩展/测试的便捷性？ |

#### 3.关键原则：

- 不可事后修补：质量属性需在设计初期融合，而非功能完成后再考虑
- 全局性影响：需在每个设计决策中权衡（*taken into account during any design decision*）。



架构的核心作用

- 当质量属性重要时，架构通过结构约束功能分配（*constrains allocation of functionality*），确保质量目标实现。
- 是解决质量问题的最适层级（most appropriate level），因质量属性不完全依赖设计/实现。



#### 4.质量属性的落地方法

1. 通用场景（General Scenarios）

- 定位：与系统无关的质量需求模板（*system-independent framework*）。
- 作用：提供可扩展的需求生成框架（如“所有API响应时间≤100ms”）。

2. 具体场景（Concrete Scenarios）

- 生成逻辑：将通用场景转化为系统专属术语（*translating into concrete terms*）。

    > 通用场景：“用户操作延迟≤1秒”
    >  → 具体场景：“电商结账页按钮点击到支付完成≤0.8秒”

3. 实施价值

- 精准定义：避免模糊描述（如“系统要快”），实现架构级可评估性（*evaluate at architecture level*）。
- 覆盖全属性：适用于性能、安全、可维护性等各类质量需求





------

### 质量属性场景化建模

> Modeling Quality Attribute Scenarios

![质量需求场景化建模](./../../public/assets/质量需求场景化建模.png)

| 要素             | 定义                                   | 案例                  |
| ---------------- | -------------------------------------- | --------------------- |
| Stimulus         | 系统需响应的条件或事件                 | 1000+并发用户请求     |
| Source           | 刺激发起者（人、系统、执行器）         | 移动端用户            |
| Artifact         | 被刺激影响的系统或组件                 | 订单支付模块          |
| Response         | 系统对刺激的响应行为                   | 返回支付结果页面      |
| Response Measure | 可量化的响应指标（质量需求落地的关键） | 99%请求响应时间≤500ms |
| Environment      | 刺激发生时系统状态                     | 系统峰值负载期        |

#### 1. 场景建模价值

> “将模糊质量需求（如'系统要快'）→ 可验证的工程指标”

- 示例转化：
     “高并发下系统稳定”
     → 刺激：5000并发用户；响应：服务不宕机；度量：错误率<0.1%

#### 2. 战术的本质

> “战术是控制质量属性响应的设计决策”

- 核心特征
    - 决策粒度小于架构模式（Pattern），如冗余（Redundancy） 是战术，主从复制（Master-Slave） 是应用该战术的模式。
    - 可组合性：战术可多层嵌套（如“数据冗余+计算冗余”组合成容错策略）。

#### 3. 战术工作逻辑

- 实战案例：

    | 质量目标 | 典型战术          | 作用机制                 |
    | -------- | ----------------- | ------------------------ |
    | 高性能   | 并发处理          | 通过线程池并行处理请求   |
    | 高可用   | 心跳检测+故障转移 | 实时监控并切换备用节点   |
    | 安全性   | 加密传输+鉴权     | 防止数据窃取与未授权访问 |

#### 4. 战术与架构的关系

- 战术集合 → 架构策略（Architectural Strategy）
- 功能决策 + 质量决策 → 完整系统设计

#### 5. 决策分类与目标

> 架构 = 7类设计决策的集合（决策间可能重叠）

| 决策类别                       | 核心目标                      | 关联质量属性案例                |
| ------------------------------ | ----------------------------- | ------------------------------- |
| Allocation of responsibilities | 明确功能/质量责任的归属       | 将安全审计责任分配给独立模块    |
| Coordination model             | 控制组件间协作机制            | 事件驱动模型提升可扩展性        |
| Data model                     | 定义数据结构与流动规范        | 数据分片策略优化查询性能        |
| Management of resources        | 管理有限资源（CPU/内存/带宽） | 请求限流保障系统稳定性          |
| Mapping among elements         | 规范架构元素映射关系          | 微服务与容器的映射支持弹性部署  |
| Binding time decisions         | 控制行为绑定时机              | 运行时依赖注入提升灵活性        |
| Choice of technology           | 技术栈选型约束                | 选型Kafka满足高吞吐消息队列需求 |

#### 6. 决策与战术的联动

> 设计决策是战术的承载容器

- 示例链：
     质量目标（高性能）
     → 战术：资源分区
     → 决策：\`Management of resources\`（资源分区策略） + \`Mapping among elements\`（CPU密集型服务绑定专用节点）



### 可用性

#### 1.可用性核心概念

1.1 定义与度量

- 本质：系统在规定时间内可提供服务的比例（\`proportion of required time usable\`）。
- 量化公式： $\\text{Availability} = \\frac{\\text{MTBF}}{\\text{MTBF} + \\text{MTTR}}$
    - MTBF（平均故障间隔时间）：系统正常运行的平均时长
    - MTTR（平均修复时间）：故障后恢复服务的平均时长
- 计划停机：计算可用性时通常不计入（如维护窗口）

1.2 服务级别协议（SLA）标准

| 可用性   | 年停机时间  | 业务影响                 |
| -------- | ----------- | ------------------------ |
| 99%      | 3天15.6小时 | 基础服务（内部系统）     |
| 99.9%    | 8小时46分钟 | 普通商用系统             |
| 99.99%   | 52分钟      | 企业级应用（如ERP）      |
| 99.999%  | 5分钟       | 关键基础设施（支付系统） |
| 99.9999% | 32秒        | 航天/金融核心系统        |

> *示例：AWS EC2 承诺 99.95%!年(MISSING)可用性（年停机≤4.38小时）*

#### 2.高可用性设计策略

2.1 故障响应全链条优化

- 目标：缩短 \`故障检测时间\` → \`修复时间\` → \`重启时间\`
- 关键技术：
    - 消除单点故障（SPoF）：冗余设计（多节点/多机房）
    - 故障转移（Failover）：主备自动切换
    - 自动检测与重启：心跳监测 + 容器化快速恢复

2.2 可恢复性（Recoverability）

> *系统故障后恢复性能和数据的能力*

- 核心指标：RTO（恢复时间目标）和 RPO（数据丢失量）

#### 3. 故障分析模型

3.1故障术语体系

| 术语    | 定义                               |
| ------- | ---------------------------------- |
| Fault   | 故障源（硬件损坏、软件缺陷）       |
| Error   | 故障引发的中间错误状态             |
| Failure | 系统无法提供预期服务（可观测失效） |
| Outage  | 服务中断期                         |

> *因果关系：Fault → Error → Failure → Outage*

3.2工程分析方法

- 故障树分析（FTA）：

    ![FAT](./../../public/assets/FAT.png)

    - 逻辑门：AND/OR门描述故障传播路径
    - 事件类型：
        - 基本事件（●）：原子故障
        - 未展开事件（◆）：复杂子系统

- 失效模式分析（FMECA）：

    | 组件 | 故障概率    | 故障模式 | 比例 | 关键影响概率 |
    | ---- | ----------- | -------- | ---- | ------------ |
    | A    | \`1×10^{-3}\` | Short    | 5%   | \`5×10^{-5}\`  |
    | B    | \`1×10^{-3}\` | Open     | 90%  | 0（非关键）  |

    > *量化故障模式的临界性（Criticality）*

#### 4. 可用性场景设计框架

| 场景要素         | 可能值                                                       |
| ---------------- | ------------------------------------------------------------ |
| Source           | 人/硬件/软件/物理环境                                        |
| Stimulus         | 故障类型：崩溃/响应超时/数据遗漏                             |
| Artifact         | 处理器/通信通道/数据库                                       |
| Environment      | 正常运行/启动/修复模式/过载                                  |
| Response         | 1. 检测：记录故障+告警  2. 恢复：隔离故障源+降级运行+数据修复 |
| Response Measure | 可用时间区间/故障检测耗时/修复耗时/降级模式持续时间          |

> *示例场景：*
>
> - 刺激：数据库节点崩溃（Stimulus）
> - 响应：10秒内切换备节点，1分钟内恢复数据一致性（Response Measure）



#### 5. 故障检测、故障修复

故障检测

|       策略名称       |                           检测机制                           | 运行层级 |                 适用场景                 |
| :------------------: | :----------------------------------------------------------: | :------: | :--------------------------------------: |
|      Ping/Echo       | 组件A发出Ping信号 → 组件B需在预设时间内返回Echo响应；超时视为故障 |  跨进程  | 负责同一任务的组件组（如分布式节点集群） |
| Heartbeat (Dead Man) | 组件定期发送心跳消息（可含数据） → 监听组件未收到心跳则判定故障 → 通知修复组件处理 |  跨进程  |     主从架构系统（如数据库主备监测）     |
|      Exception       |     进程内发生异常 → 触发同进程内的异常处理程序进行响应      |  进程内  |        单点服务的内部逻辑错误识别        |

冗余类故障恢复

|      策略名称      |                           核心机制                           |   故障切换影响   |              应用案例              |
| :----------------: | :----------------------------------------------------------: | :--------------: | :--------------------------------: |
| Active Redundancy  | 所有冗余组件并行处理事件并保持相同状态 → 仅采用一个响应输出（其余丢弃） → 故障时实时切换无停机 |    接近零停机    |   证券实时交易系统、高频撮合引擎   |
| Passive Redundancy | 主组件处理事件 → 同步状态更新至备用组件 → 故障时需验证备份状态时效性后再切换服务 | 短暂中断（秒级） | 银行核心账务系统、状态强一致性服务 |
|       Spare        |      预配置备用计算平台 → 可替换多种不同类型的故障组件       |  依赖初始化时间  |          云计算热备主机池          |

数据一致性故障恢复

|      策略名称       |                           实现逻辑                           | 数据安全保障 |            典型场景            |
| :-----------------: | :----------------------------------------------------------: | :----------: | :----------------------------: |
|       Voting        | 冗余处理器接收相同输入 → 独立计算输出 → 表决器比对结果 → 异常结果被剔除 |  防局部篡改  |  航天控制系统（多机冗余表决）  |
|     Transaction     |   绑定多个操作步骤 → 形成原子事务 → 任意步骤失败则整体回滚   | 数据强一致性 |    电商支付流程、订单创建链    |
| Checkpoint/Rollback | 定期/事件触发 → 保存系统一致性状态快照 → 故障时回滚至最近检查点重新执行 | 避免重复计算 | 科学计算任务、长周期批处理作业 |

状态管理类故障恢复

|         策略名称         |                           操作流程                           |  状态同步机制  |               价值               |
| :----------------------: | :----------------------------------------------------------: | :------------: | :------------------------------: |
|     Shadow Operation     | 故障组件恢复后 → 先以影子模式模拟正常组件行为 → 验证无误后重新接入服务 | 无状态丢失风险 | 路由器热补丁更新、无中断服务升级 |
| State Re-synchronisation | 主动/被动冗余场景下 → 故障组件恢复后需升级至最新状态才能重新服务 | 需额外同步操作 |   在线游戏服务器、实时对战平台   |

组件管控类故障恢复

|       策略名称       |                           核心目的                           | 主动/被动性 |        技术对标        |
| :------------------: | :----------------------------------------------------------: | :---------: | :--------------------: |
| Removal from Service | 主动停用组件 → 执行预防性维护（如修复内存泄漏） → 避免潜在故障发生 | 主动预防型  |   计划性系统维护窗口   |
|   Process Monitor    | 检测到进程故障 → 监控程序自动销毁故障实例 → 创建新实例并初始化（类似Spare策略） | 被动响应型  | Kubernetes Pod自愈机制 |



### 互操作性

#### 1.互操作性定义与要素

| 概念              | 核心要点                                                     |
| ----------------- | ------------------------------------------------------------ |
| 定义              | 系统间在特定情境下有意义地交换信息的程度（*meaningful exchange of information*） |
| 关键能力          | 句法互操作（Syntax）: 数据交换能力  语义互操作（Semantic）: 数据正确解析能力 |
| 情境必要性        | 需明确：*与谁（whom）*、*用什么（what）*、*在什么情况下（context）* |
| 接口（Interface） | 信息交换通道（类比人类语言传递：*"Charlene said that Kim told her…"*） |
| 两大核心机制      | 服务发现（Discovery）:   - 定位目标服务位置/身份/接口<br> 响应处理（Response Handling）:  - 返回请求者  - 转发至其他系统  - 广播至所有相关方 |

#### 2.互操作性场景建模

1. 通用场景模板

| 场景要素                 | 可能值                                                       |
| ------------------------ | ------------------------------------------------------------ |
| Source（源）             | 发起互操作请求的系统（如车辆信息系统）                       |
| Stimulus（刺激）         | 系统间信息交换请求                                           |
| Artifact（工件）         | 需互操作的系统                                               |
| Environment（环境）      | 运行时发现系统 或 运行前已知系统                             |
| Response（响应）         | - 合理拒绝请求并通知相关方  - 接受请求并成功交换信息  - 记录请求日志 |
| Response Measure（度量） | 成功交换率/延迟/数据准确性（如99.9%!信(MISSING)息正确包含率） |

2. 示例场景

| 要素        | 具体值                                      |
| ----------- | ------------------------------------------- |
| Source      | 车辆信息系统                                |
| Stimulus    | 发送车辆当前位置                            |
| Artifact    | 交通监控系统                                |
| Environment | 运行前已知系统（预配置协作关系）            |
| Response    | 将位置与交通数据融合 → 叠加至谷歌地图并广播 |
| 度量        | 信息正确包含率 ≥99.9%!                      |

#### 3.互操作性实现战术

战术分类与机制

| 战术类别                      | 战术名称              | 实现机制                               | 案例                       |
| ----------------------------- | --------------------- | -------------------------------------- | -------------------------- |
| Locate（定位）                | HDiscover Service     | 通过目录服务（如注册中心）搜索可用服务 | Kubernetes服务发现（etcd） |
|                               | Levels of Indirection | 多级间接寻址（降低耦合性）             | DNS解析链 → 微服务网关     |
| Manage Interfaces（接口管理） | Orchestrate           | 控制中心协调服务调用序列（编排流程）   | Apache Camel（路由引擎）   |
|                               | Tailor Interface      | 动态增删接口能力（适配不同消费者需求） | GraphQL接口按需返回字段    |

#### 4.互操作性策略全流程

![互操作性](./../../public/assets/互操作性.png)

流程逻辑：

1. 发起请求 → 2. 定位目标服务（发现/寻址）→ 3. 管理接口交互（编排/适配）→ 4. 完成互操作





### 可修改性

#### 1. 可修改性定义与成本模型

| 核心概念 | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| 本质     | 应对变更的能力：衡量修改代码/功能/配置所需的时间与金钱成本，以及对其他功能/质量属性的影响。 |
| 双重成本 | 准备成本（Preparing for change）  <br>实施成本（Making the change） |
| 决策公式 | $N \\times C_{\\text{无机制}} \\leq C_{\\text{装机制}} + (N \\times C_{\\text{有机制}})$（\`N\`：预期修改次数；\`C\`：成本） |
| 规划四问 | 1. 什么会变？（What can change?）   <br/> 2. 变更概率？（Likelihood?）   <br/> 3. 何时变？谁变？（When/Who?）  <br/>  4. 成本多高？（Cost?） |

> 公式关键：若预期变更次数 \`N\` 过少，昂贵的修改机制可能不划算。

#### 2.可修改性通用场景模板

| 场景要素                 | 可能值                                                       |
| ------------------------ | ------------------------------------------------------------ |
| Source（来源）           | 终端用户、开发者、系统管理员                                 |
| Stimulus（刺激）         | 增/删/改功能、调整质量属性/容量/技术的指令                   |
| Artifact（工件）         | 代码、数据、接口、组件、资源、配置                           |
| Environment（环境）      | 设计时、编译时、构建时、启动时、运行时                       |
| Response（响应）         | 执行修改 → 测试修改 → 部署修改                               |
| Response Measure（度量） | 受影响工件的数量/大小/复杂度    <br/> 工作量/日历时间/资金成本    <br/> 对其他功能/质量属性的影响   <br/> 引入的新缺陷 |

#### 3.可修改性示例场景

- 开发者（Source）在设计时（Environment）
- 提出修改UI请求（Stimulus）
- 修改代码（Artifact）并完成单元测试（Response）
- 度量指标：3小时内完成（Response Measure）

#### 4.可修改性实现战术

核心战术目标：降低修改成本与影响范围

| 战术类别       | 具体策略                                    | 作用机制                                               |
| -------------- | ------------------------------------------- | ------------------------------------------------------ |
| 减小模块复杂度 | 拆分模块（Split Module）                    | 大模块 → 多个小模块，降低单次修改范围                  |
| 提高内聚性     | 增强语义内聚（Increase Semantic Coherence） | 同功能模块合并，无关功能分离（如将支付与日志模块拆解） |
| 降低耦合度     | 封装接口（Encapsulate）                     | 强制通过接口访问，隐藏实现细节                         |
|                | 引入中介（Use Intermediary）                | 解耦直接依赖（如用消息队列代替服务直调）               |
|                | 限制依赖（Restrict Dependencies）           | 约束模块间依赖路径（如禁止循环依赖）                   |
|                | 抽象公共服务（Abstract Common）             | 复用通用能力减少重复修改                               |
| 延迟绑定时机   | 延迟绑定（Defer Binding）                   | 运行时动态配置参数（如从数据库读取而非硬编码）         |

> 可修改性核心逻辑：预判变更 → 量化成本 → 战术降本 → 动态调整。





### 性能

#### 1.性能本质与响应时间构成

| 性能定义                                          | 响应时间构成                                                 |
| :------------------------------------------------ | :----------------------------------------------------------- |
| 系统满足时序要求的能力  <br/>所有系统均有性能需求 | 处理时间 (processing time) —— 系统工作时间 <br/> 阻塞时间 (blocked time) —— 系统无法响应时间 |

#### 2.性能通用场景模板

| 场景要素         | 可能值                                       |
| :--------------- | :------------------------------------------- |
| Source           | 系统内部/外部来源                            |
| Stimulus         | 周期性/突发/随机事件到达                     |
| Environment      | 正常/紧急/峰值/过载模式                      |
| Response         | 处理事件 或 变更服务等级                     |
| Response Measure | 延迟/吞吐量/抖动/遗漏率/截止期限（关键指标） |

#### 3. 性能场景示例

| 要素             | 值                       |
| ---------------- | :----------------------- |
| Source           | 用户                     |
| Stimulus         | 发起交易请求             |
| Environment      | 正常运作模式             |
| Response         | 处理交易                 |
| Response Measure | 平均延迟≤2秒（核心约束） |

#### 4.性能优化战术分类

| 优化方向                          | 具体战术                                                     |
| :-------------------------------- | :----------------------------------------------------------- |
| 控制资源需求 (Reduce Demand)      | 1. 管理采样率（降频） 2. 限制事件响应（队列缓冲） 3. 优先级调度（关键事件优先） 4. 减少中间开销 5. 限定执行时间 6. 提升资源效率 |
| 管理资源供给 (Increase Resources) | 1. 增加硬件资源（CPU/内存/网络） 2. 引入并发处理 3. 计算副本（负载均衡） 4. 数据副本（缓存/复制） 5. 队列容量控制 6. 资源调度策略 |





### 安全性

#### 1. 安全本质与CIA模型

| 核心目标      | 三大特性                 | 关键定义                                    |
| ------------- | ------------------------ | ------------------------------------------- |
| 保护数据/服务 | 保密性 (Confidentiality) | 防未授权访问（\`unauthorized access\`）       |
|               | 完整性 (Integrity)       | 防未授权篡改（\`unauthorized manipulation\`） |
|               | 可用性 (Availability)    | 保障合法使用（\`legitimate use\`）            |

> CIA三元组是安全设计的基石

#### 2. 安全通用场景模板

| 场景要素                 | 关键说明                                                     |
| ------------------------ | ------------------------------------------------------------ |
| Source（来源）           | 内部/外部人员或系统（如离职员工、黑客）                      |
| Stimulus（刺激）         | 未授权尝试：显示/修改/删除数据、操控系统、拒绝服务           |
| Artifact（工件）         | 系统服务、数据、资源                                         |
| Environment（环境）      | 在线/离线、防火墙状态、运行模式                              |
| Response（响应）         | ● 阻止未授权访问/篡改  ● 审计追踪（记录操作）  ● 实时通知攻击 |
| Response Measure（度量） | ● 系统被破坏范围  ● 攻击检测时间  ● 成功抵御攻击次数  ● 恢复耗时  ● 数据脆弱性 |

#### 4.安全场景实例：薪资系统攻击

| 要素                     | 具体值                          |
| ------------------------ | ------------------------------- |
| Source（来源）           | 远程不满员工                    |
| Stimulus（刺激）         | 尝试修改工资率                  |
| Artifact（工件）         | 系统内部数据                    |
| Environment（环境）      | 正常运作模式                    |
| Response（响应）         | 维护审计追踪                    |
| Response Measure（度量） | ● 1天内恢复数据  ● 确定篡改来源 |

#### 4.安全战术分层策略

 防御全周期战术链

\`\`\`mermaid
graph LR
A[Detect 检测攻击] --> B[Resist 抵御攻击]
B --> C[React 响应攻击]
C --> D[Recover 恢复系统]
\`\`\`

核心战术清单（关键战术加粗）

| 阶段      | 战术                         | 作用                     |
| :-------- | ---------------------------- | ------------------------ |
| 检测攻击  | ● 入侵检测（比对流量特征）   | 识别异常行为             |
| (Detect)  | ● 拒绝服务检测               | 监控资源耗尽             |
|           | ● 验证消息完整性（哈希校验） | 防数据篡改               |
| 抵御攻击  | ● 身份认证                   | 确认用户身份             |
| (Resist)  | ● 访问控制（权限分级）       | 限制敏感操作             |
|           | ● 加密数据                   | 防窃取                   |
|           | ● 最小化攻击面               | 减少暴露点               |
| 响应攻击  | ● 撤销访问权限               | 实时阻断攻击             |
| (React)   | ● 锁定系统                   |                          |
|           | ● 通知管理员                 |                          |
| 恢复系统  | ● 审计追踪                   | 溯源攻击路径             |
| (Recover) | ● 数据/服务恢复              | 结合可用性战术（如备份） |





### 可测试性

#### 1. 可测试性本质

|                        核心定义                         |                         实现前提                          |
| :-----------------------------------------------------: | :-------------------------------------------------------: |
| 通过测试暴露故障的难易程度 （\`demonstrate its faults\`） | ● 控制（\`control\`）组件输入 ● 观察（\`observe\`）输出与状态 |

> 关键模型：输入 → 系统处理 → 输出/状态 → 预言机（\`Oracle\`）验证

#### 2.通用场景框架

|         场景要素         |                        关键值                         |
| :----------------------: | :---------------------------------------------------: |
|      Source（来源）      |              测试人员/用户（手动或自动）              |
|     Stimulus（刺激）     |                代码/系统完成时触发测试                |
|     Artifact（工件）     |                     被测系统部分                      |
|     Response（响应）     |               执行测试 → 捕获结果/状态                |
| Response Measure（度量） | ● 故障发现成本 ● 测试耗时 ● 状态覆盖率 ● 风险暴露降低 |

#### 3. 示例场景

图片

![可测试性](./../../public/assets/可测试性.png)

● 环境：开发阶段
● ​​目标​​：快速验证路径覆盖

#### 4. 可测试性战术

#### 两大核心策略

|                策略                |                           子战术                            |             作用              |
| :--------------------------------: | :---------------------------------------------------------: | :---------------------------: |
| 控制与观察状态 (Control & Observe) |     ● 专用接口 ● 记录/回放 ● 沙盒隔离 ● 本地化状态存储      | 主动干预系统状态 重现故障场景 |
|   限制复杂度 (Limit Complexity)    | ● 减少组件依赖 ● 限制继承深度 ● 约束多态调用 ● 消除非确定性 |   压缩状态空间 降低测试难度   |



### Usability

####  1. 可用性定义与核心维度

| 概念     | 说明                                                         | 关键要点                       |
| -------- | ------------------------------------------------------------ | ------------------------------ |
| 本质     | 用户完成任务的易用性与系统支持能力                           | ● 关注用户达成目标的效率与体验 |
| 五大维度 | 1. 学习系统功能  2. 高效使用系统  3. 最小化错误影响（核心）  4. 系统适应用户  5. 增强信心与满意度 | ● 覆盖用户操作全生命周期       |

#### 2. 可用性场景建模

通用场景模板（关键要素）

| 要素                         | 值域                                               | 示例               |
| ---------------------------- | -------------------------------------------------- | ------------------ |
| Source                       | 最终用户（特定角色）                               | 普通用户/管理员    |
| Stimulus                     | 用户尝试：学习/高效使用/防错/适配系统              | 下载新应用并操作   |
| Response                     | 系统预判需求或提供所需功能                         | 界面自动引导操作   |
| Response Measure（核心指标） | ● 任务耗时  ● 错误数量  ● 用户满意度  ● 数据丢失量 | ≤2分钟上手（示例） |

 示例场景流程

\`\`\`mermaid
graph LR
A[用户下载新应用] --> B[系统运行时引导]
B --> C[用户高效使用]
C --> D[2分钟内掌握]
\`\`\`

#### 3. 可用性实现战术

#### 两类主动策略对比

| 策略方向                        | 战术                                                         | 作用机制                     |
| ------------------------------- | ------------------------------------------------------------ | ---------------------------- |
| 用户主动性  (User Initiative)   | ● Cancel（取消操作）  ● Undo（撤销：保存状态快照）  ● Pause/Resume（长任务暂停恢复）  ● Aggregate（聚合低级操作为组） | 赋予用户控制权  减少错误代价 |
| 系统主动性  (System Initiative) | ● 任务模型（预判用户目标）  ● 用户模型（记录用户知识水平）  ● 系统模型（管理预期行为） | 主动提供反馈与帮助           |

#### 4.战术实施逻辑链

\`\`\`mermaid
graph TB
User[用户请求] --> Tactics{战术选择}
Tactics --> UserInit[用户主动战术]
Tactics --> SystemInit[系统主动战术]
UserInit --> Feedback[实时取消/撤销/聚合]
SystemInit --> Model[任务/用户/系统模型分析]
Feedback & Model --> Result[适应用户的反馈与协助]
\`\`\`

> 极简结论：
>
> 1. 可用性 = 用户操作体验 × 系统预判能力
> 2. 设计核心：
>      \\- ​​用户侧​​：提供控制权（撤销/聚合）
>      \\- ​​系统侧​​：三模型（任务/用户/系统）预判需求
> 3. 验证指标：2分钟上手成功率（示例）为用户学习效率黄金标准







## 微服务架构





------

### 一、软件架构基础

1. 定义
    - 软件架构是系统的一组结构，包含软件元素、元素间关系及其属性（源于《Software Architecture in Practice》）。
2. 架构生命周期活动
    - 需求分析 → 架构设计 → 实现 → 测试 → 部署 → 演进。

------

### 二、架构驱动因素（Architectural Drivers）

1. 功能需求（Functional Drivers）
    - 直接支持业务目标的核心功能（如网络管理系统的“故障检测”用例）。
2. 质量属性（Quality Attribute Drivers）
    - 关键指标：性能、可用性、可修改性、安全性等。
    - 优先级评估：通过场景技术描述，结合业务重要性（H/M/L）和技术风险（H/M/L）排序（示例表格见PPT）。
3. 约束（Constraints）
    - 类型：
        - 时间/预算（如3个月项目期限限制复杂模块开发）。
        - 技术限制（如团队缺乏区块链经验时避免相关设计）。
        - 业务规则/合规（如GDPR要求的数据隐私设计）。
4. 系统类型
    - 全新系统（Greenfield）：成熟领域（标准企业应用）或新兴领域（创新应用如Google）。
    - 遗留系统（Brownfield）：对现有系统的改造。
5. 设计目标与关注点
    - 目标：预研提案、定制系统、持续演进系统的增量设计。
    - 关注点：代码结构、团队分工、日志管理、API版本控制等。

------

### 三、设计策略

1. 分解（Decomposition）
    - 将系统拆分为模块/组件，分配质量属性（如将性能需求分配到独立模块）。
2. ASR驱动设计
    - 优先满足关键架构需求（Architecturally Significant Requirements），通过模式/策略平衡非ASR需求。
3. 假设-验证循环（Generate and Test）
    - 初始假设：源于现有系统、设计模式或框架。
    - 验证方法：分析技术、设计检查表。
    - 终止条件：满足ASR或预算耗尽。

------

### 四、设计概念（Design Concepts）

1. 参考架构（Reference Architectures）
    - 提供应用蓝图（如Web应用、微服务架构）。
2. 部署模式（Deployment Patterns）
    - 物理结构设计（如N层部署、负载均衡集群）。
3. 战术（Tactics）
    - 针对质量属性的设计决策（如可用性战术：错误检测、恢复策略）。
4. 设计模式（Patterns）
    - 解决重复问题的方案（如三模冗余模式）。
5. 外部组件（Frameworks）
    - 重用代码库（如Spring框架处理依赖注入）。

------

### 五、属性驱动设计方法（ADD 3.0）

#### 8个迭代步骤：

1. 评审输入
    - 确认设计目标、功能需求、质量属性场景、约束的完整性和优先级。
2. 设定迭代目标
    - 选择待解决的驱动子集（如处理关键性能场景）。
3. 选择细化元素
    - 分解系统或模块（全新系统从整体开始，遗留系统聚焦特定组件）。
4. 选择设计概念
    - 评估方案（参考架构/模式/战术），通过利弊表、CBAM成本效益分析或原型验证决策。
5. 实例化元素与接口
    - 创建组件并分配职责（如逻辑视图、动态交互图）。
6. 绘制视图草图
    - 初步记录设计决策（避免后期遗忘）。
7. 分析设计并验证目标
    - 使用设计看板跟踪进度，检查是否满足ASR。
8. 迭代或终止
    - 未满足驱动或存在风险则继续迭代；否则输出架构。

#### 不同系统的ADD适配：

- 成熟领域全新系统：从参考架构（如三层架构）起步。
- 新兴领域系统：依赖原型和通用模式（如性能/安全战术）。
- 遗留系统改造：先理解现有架构，再增量重构（使用“绞杀者模式”逐步替换）。

------

### 六、架构文档化

1. 视图选择
    - 模块视图：代码结构（如分解视图、分层视图）。
    - C&C视图：运行时组件交互（如服务通信图）。
    - 分配视图：软件到环境的映射（如部署图）。
    - 质量视图：定制化视图（如安全视图、性能视图）。
2. 文档结构
    - 视图模板：主图示、元素目录、上下文图、可变性指南、设计理由。
    - 全局内容：文档地图、系统概览、视图映射、全局决策理由、术语表。
3. 行为文档化
    - 追踪导向：用例图、序列图描述交互流。
    - 全面模型：状态机描述完整行为。
4. 敏捷实践
    - 白板草图拍照存档，仅记录必要内容（如团队分工、接口约定）。



------

### 一、业务背景

- 公司：AD&D Hotels（中型连锁酒店，约300家分店）
- 问题：现有定价系统存在可靠性、性能、可用性和可维护性问题，导致财务损失。系统采用"直接迁移上云"（lift and shift），未充分利用云资源。
- 目标：
    - 完全替换旧系统，采用云原生架构。
    - 解决系统耦合问题（避免共享数据库等反模式）。
    - 支持敏捷开发（Scrum）和DevOps实践。

------

### 二、核心需求

#### 1. 功能性需求（Use Cases）

| ID    | 功能描述                                              |
| ----- | ----------------------------------------------------- |
| HPS-1 | 用户登录（验证身份，按权限访问酒店数据）              |
| HPS-2 | 修改价格（更新基础/固定房价，实时计算衍生价格并推送） |
| HPS-3 | 查询价格（用户或外部系统通过API查询）                 |
| HPS-4 | 管理酒店信息（税率、房型、房价规则）                  |
| HPS-5 | 管理房价规则（定义计算逻辑）                          |
| HPS-6 | 管理用户权限                                          |

#### 2. 质量属性需求（Quality Attributes）

| ID   | 属性     | 场景描述                                  |
| ---- | -------- | ----------------------------------------- |
| QA-1 | 性能     | 修改基础房价后，所有衍生价格100ms内可查询 |
| QA-2 | 可靠性   | 100%价格修改成功发布并推送至渠道系统      |
| QA-3 | 可用性   | 查询API可用性SLA 99.9%                    |
| QA-4 | 可扩展性 | 支持10万→100万次/日查询，延迟增加≤20%     |
| QA-5 | 安全性   | 用户仅访问授权功能和数据                  |
| QA-6 | 可修改性 | 新增gRPC协议端点无需修改核心组件          |
| QA-7 | 可部署性 | 系统在非生产环境间迁移无需代码修改        |
| QA-8 | 可监控性 | 100%收集价格发布的性能/可靠性指标         |
| QA-9 | 可测试性 | 所有组件支持独立集成测试                  |

#### 3. 约束（Constraints）

- 业务约束：Web浏览器访问（跨平台）、6个月交付完整系统（2个月出MVP）、初始支持REST API。
- 技术约束：云身份服务、Git代码托管、云原生优先。
- 运维约束：四个环境（开发→集成→预发布→生产），仅需支持集成/预发布环境持续部署。

------

### 三、架构设计过程（ADD迭代）

#### 迭代1：建立整体系统结构

- 目标：定义云原生架构框架，解决核心质量属性（性能、可靠性、安全性）。

- 关键决策：

    - 模式选择：CQRS（命令查询职责分离）分离价格修改（命令端）和查询端。
    - 架构风格：微服务（命令微服务、查询微服务、导出微服务）。
    - 核心组件：
        - 事件总线：Apache Kafka（保障消息顺序和持久化）。
        - 前端：Angular框架（响应式Web应用）。
        - 安全：API网关 + JWT令牌 + HTTPS加密。
        - 部署：Docker容器（跨环境可移植性）。
    - 云服务：托管数据库/Kafka/容器编排服务（减少运维负担）。

- 输出视图：

    *（系统组件图：前端、API网关、微服务、Kafka、外部系统）*

#### 迭代2：支持核心功能模块

- 目标：细化微服务内部结构，支持价格修改（HPS-2）和查询（HPS-3）。
- 关键决策：
    - 领域模型：酒店、房型、税率、价格规则等实体（UML类图）。
    - 数据库选型：
        - 命令端：关系数据库（管理复杂实体关系）。
        - 查询端：非关系数据库（高效存储价格事件）。
    - 技术栈：Spring框架（控制器-服务-仓储分层）。
    - API设计：REST + Swagger文档（OpenAPI规范）。
    - 配置管理：外部化配置（环境变量注入）。
- 输出视图：
    - 命令端微服务模块图（控制器、服务层、领域模型、仓储）。
    - 价格修改序列图（用户→前端→命令微服务→Kafka→查询微服务）。

#### 迭代3：保障可靠性与可用性

- 目标：满足QA-2（可靠性）、QA-3（可用性）、QA-4（可扩展性）。

- 关键决策：

    - 故障处理：Kafka事件重试（导出微服务→渠道系统失败时重放）。
    - 高可用：云服务多可用区部署（数据库/Kafka/容器编排）。
    - 扩展性：查询微服务多副本 + 负载均衡。
    - 监控：容器编排服务自动重启故障实例。

- 输出视图：

    *（高可用部署图：主/备可用区 + DNS故障切换）*

#### 迭代4：实现DevOps流水线

- 目标：支持QA-7（可部署性）和CRN-5（持续部署）。

- 关键决策：

    - CI/CD流水线：Git平台内置流水线（每个微服务独立构建）。
    - 镜像管理：云容器仓库存储Docker镜像。
    - 基础设施即代码：云服务API描述资源（一键创建环境）。

- 输出视图：

    *（流水线活动图：代码提交→构建镜像→部署到集成/预发布环境）*

------

### 四、关键设计亮点

1. 事件驱动解耦：
    - Kafka作为唯一数据源，确保价格修改的可靠传递。
    - 导出微服务无状态，从Kafka重试失败事件（无需额外存储）。
2. 异构数据存储：
    - 命令端：关系数据库（强一致性，管理业务规则）。
    - 查询端：非关系数据库（高性能读，灵活存储价格事件）。
3. 云原生优化：
    - 托管服务（数据库/Kafka/容器编排）降低运维复杂度。
    - 容器化 + 外部配置实现环境无缝迁移。
4. 增量式设计：
    - 首迭代MVP支持核心场景（价格修改/查询）。
    - 后续迭代逐步增强质量属性（可靠性→扩展性→部署流水线）。

------

### 五、总结与挑战

- 成果：满足6个月交付期限，MVP在2个月内演示。
- 未决问题：API版本管理（QA-6）、端到端监控（QA-8）。
- 经验教训：
    - 优势：CQRS+微服务有效分离读写负载；云托管服务加速高可用实现。
    - 挑战：Kafka配置复杂性；跨团队协调（微服务需独立开发）。

> 核心启示：ADD方法通过4次迭代将需求转化为可落地的云原生架构，平衡了功能、质量和约束，为类似系统改造提供完整范本。



------

### 一、微服务架构基础

#### 1. 架构风格演进

| 架构风格   | 特点                                                         | 适用场景                     | 局限性                                       |
| ---------- | ------------------------------------------------------------ | ---------------------------- | -------------------------------------------- |
| 单体架构   | 功能高度集成，进程内通信；单一数据库事务管理；部署简单（如WAR包） | 业务简单、低并发场景         | 臃肿难维护、扩展性差、技术栈僵化（“大泥球”） |
| 分层架构   | MVC三层解耦（表现层/业务层/数据层）；符合SOLID原则           | 中等复杂度系统               | 层级调用性能损耗；易退化为紧耦合网状结构     |
| SOA架构    | 服务化组件+ESB总线；服务复用与组合                           | 企业级系统集成               | ESB性能瓶颈；协议沉重（如SOAP）；演化困难    |
| 微服务架构 | 轻量级通信（REST/gRPC）；独立部署/扩展；去中心化治理         | 高并发、快速迭代的互联网系统 | 分布式复杂性（事务、调试、运维）             |

#### 2. 微服务定义与特性

- 核心定义（Martin Fowler）：

    > 将应用拆分为一组小型服务，每个服务：
    >  ① 运行在独立进程中
    >  ② 通过轻量级机制通信（HTTP/RPC）
    >  ③ 围绕业务能力构建
    >  ④ 可独立部署与技术异构

- 关键特性：

    - 服务组件化：进程外组件，通过API通信（非共享内存）
    - 业务能力导向：按业务域划分服务（如订单、支付）
    - 去中心化：
        - 治理：各服务自主选型技术栈
        - 数据：私有数据库（无共享数据库）
    - 基础设施自动化：依赖CI/CD、容器化（Docker/K8s）
    - 容错设计：熔断、限流、链路追踪

#### 3. 微服务核心优势

| 维度       | 优势                                             |
| ---------- | ------------------------------------------------ |
| 开发效率   | 小团队自治（“双披萨团队”）；技术栈灵活；独立迭代 |
| 可维护性   | 单一职责服务；代码量小易理解                     |
| 可扩展性   | 按需伸缩热点服务（如订单服务独立扩容）           |
| 可靠性     | 故障隔离（单服务宕机不影响全局）                 |
| 部署灵活性 | 独立部署；灰度发布；快速回滚                     |

------

### 二、微服务设计核心模式

#### 1. 服务拆分模式

| 拆分策略           | 方法论                                                       | 案例                                     |
| ------------------ | ------------------------------------------------------------ | ---------------------------------------- |
| 业务能力拆分       | 按企业业务域划分（如电商：订单/库存/物流）                   | FTGO应用：订单服务、配送服务、支付服务   |
| DDD子域拆分        | 识别限界上下文（Bounded Context）：  - 核心域（订单）  - 通用域（用户）  - 支撑域（日志） | 订单子域 → 订单服务；支付子域 → 支付服务 |
| 动静态调用关系拆分 | 基于调用频率/变更频率聚类；适用于遗留系统改造                | 通过字节码分析拆分高频变更模块           |

#### 2. 通信模式

| 模式                      | 解决的核心问题               | 实现方案                                                     |
| ------------------------- | ---------------------------- | ------------------------------------------------------------ |
| 服务注册与发现            | 动态定位服务实例             | - 应用层：Eureka（自注册+客户端发现）  - 平台层：K8s Service（DNS+服务端发现） |
| API网关                   | 统一入口、协议转换、安全控制 | Spring Cloud Gateway / Kong；支持路由、限流、认证            |
| 断路器（Circuit Breaker） | 防止雪崩效应                 | Hystrix / Resilience4j；状态机：闭合 → 断开 → 半开           |
| 异步消息                  | 解耦服务；最终一致性         | Kafka / RabbitMQ；事件驱动架构（如订单创建 → 支付触发）      |

#### 3. 数据一致性模式

| 模式     | 原理                                           | 适用场景                          |
| -------- | ---------------------------------------------- | --------------------------------- |
| Saga模式 | 分布式事务拆分+补偿机制（TCC）                 | 跨服务事务（如订单取消→库存回滚） |
| CQRS     | 读写分离：命令端更新DB → 事件 → 查询端更新视图 | 读多写少场景（如商品详情页）      |
| API组合  | 聚合多个服务数据返回客户端                     | 简单查询（需注意性能）            |

#### 4. 部署模式对比

| 部署模式           | 资源隔离 | 启动速度     | 管理成本 | 代表技术     |
| ------------------ | -------- | ------------ | -------- | ------------ |
| 单主机多实例       | 低       | 快           | 低       | Tomcat多进程 |
| 虚拟机单实例       | 高       | 慢（分钟级） | 中       | AWS EC2      |
| 容器化部署         | 中       | 快（秒级）   | 中       | Docker + K8s |
| Serverless无服务器 | 高       | 冷启动慢     | 低       | AWS Lambda   |

#### 5. 可观测性模式

| 模式        | 核心目标          | 工具栈                               |
| ----------- | ----------------- | ------------------------------------ |
| 日志聚合    | 统一收集/检索日志 | ELK（Elasticsearch+Logstash+Kibana） |
| 分布式追踪  | 全链路请求追踪    | Zipkin / Jaeger + OpenTracing        |
| 指标监控    | 实时监控服务性能  | Prometheus + Grafana                 |
| 健康检查API | 快速检测服务状态  | Spring Boot Actuator /health端点     |

------

### 三、关键实践与挑战

#### 1. 微服务拆分实战步骤

1. 定义领域模型：分析需求名词（如订单、用户）
2. 识别系统操作：分析需求动词（如创建订单、支付）
3. 映射服务：按业务能力/子域分配操作到服务
4. 设计API：定义服务间协作接口（如订单服务调用支付API）
5. 重构策略：
    - 绞杀者模式：逐步替换单体应用（新功能→微服务）
    - 模块提取：将单体模块拆分为独立服务

#### 2. 典型挑战与对策

| 挑战       | 解决方案                                       |
| ---------- | ---------------------------------------------- |
| 分布式事务 | Saga模式 + 幂等设计；避免2PC                   |
| 跨服务查询 | CQRS物化视图 / API组合 + 缓存                  |
| 运维复杂度 | 容器编排（K8s）；基础设施即代码（Terraform）   |
| 测试复杂性 | 契约测试（Pact）；容器化测试（Testcontainers） |
| 网络延迟   | 轻量协议（gRPC）；超时重试机制                 |

#### 3. 架构演进建议

- 何时采用微服务？：
     业务复杂度高 + 团队规模 > 50人 + 需快速迭代
- 架构适应度函数：
     定义量化指标（如部署频率 > 5次/天；延迟 < 100ms）指导演进
- 避免过度拆分：
     服务粒度需平衡（过细 → 运维负担；过粗 → 耦合度高）

------

### 四、总结

- 核心价值：微服务通过解耦与自治提升系统弹性与交付效率。
- 适用场景：高并发、快速迭代的中大型分布式系统（如电商/金融平台）。
- 成功前提：
    - 自动化基础设施（CI/CD/K8s）
    - 跨职能团队协作（DevOps文化）
    - 合理的拆分策略（避免“为了微服务而微服务”）

> 关键启示：微服务是架构演进的产物而非目标，需结合业务上下文选择模式。参考案例：[FTGO应用架构](https://microservices.io/) 展示了从单体到微服务的完整重构路径。

`;export{n as default};
