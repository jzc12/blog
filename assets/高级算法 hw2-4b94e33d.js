import{o as t,c as l,a as p}from"./index-516e8084.js";const _="/blog/assets/hw2-a77c37d0.png",o={class:"markdown-body"},s="2025-06-29T00:00:00.000Z",u="2025-06-29T00:00:00.000Z",x="hw",c="高级算法作业2",m={__name:"高级算法 hw2",setup(n,{expose:i}){return i({frontmatter:{date:"2025-06-29T00:00:00.000Z",updated:"2025-06-29T00:00:00.000Z",category:"hw",summary:"高级算法作业2"}}),(e,$)=>(t(),l("div",o,$[0]||($[0]=[p('<h1>hw2</h1><h2>0</h2><p><img src="'+_+'" alt="hw2"></p><h2>1</h2><p>先梳理简单制表哈希</p><p>分为三个步骤</p><ol><li>把输入的 X 按字节或者多个字节拆解 为 ${x_1, x_2,…,x_c}$ , 每个 $x_i$是 X 按顺序的 d 位的值</li><li>c 个随即表的初始化，每个表 有 $2^d$ 个数</li><li>计算 $h(x) = T₀[x₀] \\oplus T₁[x₁] \\oplus … \\oplus T_{c-1}[x_{c-1}]$</li></ol><p>可能存在的问题：</p><p>（1）简单制表要求将键拆分成 c个固定位宽 d的值。对不同长度的值，需要填充或截断处理，而且是线性结构。</p><p>（2）简单制表被证明是 4-独立的，但在要求极高质量哈希且需要高于 4-独立性保证的应用中，简单制表可能会存在问题。</p><p>针对问题 1.</p><p><strong>扭曲制表哈希</strong></p><p>针对问题2.</p><p><strong>双表制表哈希</strong></p><p>双表制表哈希想法就是再单个简单制表哈希的基础上再套一层，相同的三个步骤再走一遍，只是 c 和 d 的值在第二次的映射可以变化。</p><p>我觉得加为两层的制表哈希想法很简单，但是确实很有用，第二层提高了更多的独立性，但是引入的问题是更多的随机表初始化的消耗和计算复杂度的增加。</p><hr><h2>2</h2><p>定义 $A_i$ 为 $A$ 的第 $i$ 行，记：</p><p>$Y_i = \\langle A_i, \\mathbf{x} \\rangle = \\sum_{j=1}^d A_{ij} x_j$</p><p>则$ |A \\mathbf{x}|<em>2^2 = \\sum</em>{i=1}^k Y_i^2$</p><p>$A_{ij} \\sim \\mathcal{N}(0, 1/k)$，$\\mathbf{x}$ 为单位向量，故每个 $Y_i \\sim \\mathcal{N}(0, 1/k)$，所以：</p><p>$\\mathbb{E}[|A \\mathbf{x}|<em>2^2] = \\sum</em>{i=1}^k \\mathbb{E}[Y_i^2] = k \\cdot \\frac{1}{k} = 1$</p><p>$\\because$</p><p>$\\mathbb{E}[Y_i^4] = 3 \\cdot \\operatorname{Var}(Y_i)^2 = 3 \\cdot \\left(\\frac{1}{k}\\right)^2 = \\frac{3}{k^2}$</p><p>$\\operatorname{Var}(Y_i^2) = \\mathbb{E}[Y_i^4] - (\\mathbb{E}[Y_i^2])^2 = \\frac{3}{k^2} - \\frac{1}{k^2} = \\frac{2}{k^2}$</p><p>$\\therefore$</p><p>$\\operatorname{Var}(|A\\mathbf{x}|_2^2) = k \\cdot \\operatorname{Var}(Y_i^2) = k \\cdot \\frac{2}{k^2} = \\frac{2}{k}$</p><p>若 $|\\mathbf{x}|_\\infty \\leq \\alpha$，则：</p><p>$\\operatorname{Var}(Y_i) = \\frac{1}{k} \\sum_{j=1}^d x_j^2 \\leq \\frac{1}{k} \\cdot d \\cdot \\alpha^2$</p><p>$\\therefore$</p><p>$\\operatorname{Var}(Y_i^2) \\leq 2 \\cdot (\\operatorname{Var}(Y_i))^2 \\leq 2 \\cdot \\left( \\frac{d \\alpha^2}{k} \\right)^2 = \\frac{2 d^2 \\alpha^4}{k^2}$</p><p>总方差为：</p><p>$\\operatorname{Var}(|A\\mathbf{x}|_2^2) \\leq k \\cdot \\frac{2 d^2 \\alpha^4}{k^2} = \\frac{2 d^2 \\alpha^4}{k}$</p><p>由切比雪夫不等式：</p><p>$\\mathbb{P}\\left[ \\left| |A\\mathbf{x}|_2^2 - 1 \\right| &gt; \\epsilon \\right] \\leq \\frac{\\operatorname{Var}(|A\\mathbf{x}|_2^2)}{\\epsilon^2} \\leq \\frac{2 d^2 \\alpha^4}{k \\epsilon^2}$</p><p>右边不超过 $\\delta$，得：</p><p>$k \\geq \\frac{2 d^2 \\alpha^4}{\\delta \\epsilon^2}$</p><p>$\\therefore $ $\\mathbf{x} \\in \\mathbb{S}^{d-1}$ 且 $|\\mathbf{x}|_\\infty \\leq \\alpha$，保证：$\\mathbb{P}\\left[ \\left| |A\\mathbf{x}|_2^2 - 1 \\right| &gt; \\epsilon \\right] &lt; \\delta$ 的前提下，可以降维到 $ O\\left( \\frac{d^2 \\alpha^4}{\\delta \\epsilon^2} \\right)$</p><hr><h2>3</h2><p>LSH 的核心目标是：</p><ul><li><strong>让“相近”的点有较高概率哈希到同一个桶中</strong>；</li><li><strong>让“较远”的点哈希到同一个桶中的概率较低</strong>。</li></ul><p>我们需要根据给定的距离函数 d(x,y)d(x, y) 来构造符合上述性质的哈希函数族。</p><p><strong>1</strong></p><p>我们考虑的空间是：</p><p>([0,n]d,  d(x,y)=∑i(min⁡{∣xi−yi∣,n−∣xi−yi∣})2)([0,n]^d, ; d(x,y) = \\sqrt{\\sum_i (\\min{|x_i - y_i|, n - |x_i - y_i|})^2})</p><h4>✅ 这是一个“环形”度量空间：</h4><ul><li>可以理解为每一维是长度为 nn 的环（mod nn）。</li><li>比如如果在第 ii 维上 ∣xi−yi∣&gt;n/2|x_i - y_i| &gt; n/2，那么“近”实际上意味着绕一圈反方向走。</li></ul><h4>🔧 LSH设计思路：</h4><ul><li><p><strong>启发</strong>：该距离与欧几里得空间类似，但在每一维上有模 nn 的约束。</p></li><li><p><strong>方法</strong>：我们可以使用类似 E2LSH（欧几里得空间下的 LSH）的方法，并在哈希时使用模运算。</p><p>对每个点 x∈[0,n]dx \\in [0,n]^d，可以定义哈希函数为：</p><p>ha,b(x)=⌊(a⋅x+b) mod nw⌋h_{a,b}(x) = \\left\\lfloor \\frac{(a \\cdot x + b) \\bmod n}{w} \\right\\rfloor</p><ul><li>其中 aa 是一个随机向量，b∈[0,w]b \\in [0, w]，ww 是桶宽；</li><li>模运算使得我们处理的是“环形距离”。</li></ul></li></ul><h4>✏️ 解释：</h4><ul><li>由于环形度量空间在本质上只是每一维上做模 nn 的投影，我们只要在哈希函数中显式处理这个周期性即可；</li><li>因此借用欧几里得空间的 LSH 方法，加上模 nn，即可实现这一空间下的 LSH。</li></ul><p><strong>2</strong></p><p>度量空间为单位球面 Sd−1\\mathbb{S}^{d-1}，距离定义为：</p><p>d(x,y)=arccos⁡(⟨x,y⟩)d(x,y) = \\arccos(\\langle x, y \\rangle)</p><p>即两个单位向量之间的夹角。</p><h4>✅ 这是“球面几何”上的距离：</h4><ul><li>所有向量都是单位向量；</li><li>相似度用“夹角”来衡量，夹角越小，向量越“相近”。</li></ul><h4>🔧 LSH设计思路：</h4><ul><li><p><strong>方法</strong>：使用 <strong>随机超平面（Random Hyperplane）法</strong>。</p></li><li><p>这是专门针对余弦相似度或球面距离设计的 LSH。</p><p>哈希函数形式如下：</p><p>hv(x)={1if ⟨v,x⟩≥00otherwiseh_v(x) = \\begin{cases} 1 &amp; \\text{if } \\langle v, x \\rangle \\ge 0 \\ 0 &amp; \\text{otherwise} \\end{cases}</p><ul><li>其中 vv 是一个从单位高斯分布中采样的随机向量；</li><li>本质上是看 xx 在随机超平面哪一侧。</li></ul></li></ul><h4>✏️ 解释：</h4><ul><li>这样的哈希函数能够满足：如果两个向量夹角较小，它们被同一个随机超平面分到同一侧的概率较高；</li><li>夹角较大的向量落入同一侧的概率较低；</li><li>完美符合 LSH 的性质。</li></ul><hr><h2>4</h2><p>Oblivious Subspace Embedding（OSE）旨在将任意 $d$ 维子空间 $\\Pi$ 映射到低维空间，同时近似保留所有向量的 $\\ell_2$ 范数。</p><p>常用构造为稀疏矩阵 $S \\in \\mathbb{R}^{m \\times d}$：</p><ul><li>随机选择映射桶 $h(j) \\in {1, …, m}$</li><li>选择符号 $\\sigma(j) = \\pm 1$</li><li>设置 $S_{h(j), j} = \\sigma(j)$，其余为 0</li></ul><p>对于任意向量 $x$，有：</p><p>(1−ε)∥x∥2≤∥Sx∥2≤(1+ε)∥x∥2(1 - \\varepsilon)|x|_2 \\leq |Sx|_2 \\leq (1 + \\varepsilon)|x|_2</p><p>当 $m = O(d^2/\\varepsilon^2)$ 时，上述保证以高概率成立。该技术在稀疏数据降维、线性回归等场景中应用广泛。</p><hr><h2>5</h2><p>在标准的网络流问题中，边（arc）有容量限制，而节点（vertex）没有容量限制。但在您描述的问题中，每条边的容量为无穷大（即不限制流量），而每个节点 $i$ 有容量限制 $c_i$，表示流经该节点的总流量不能超过 $c_i$（包括流入和流出的总和，对于源点和汇点，也适用类似约束：源点 $s$ 的流出量受 $c_s$ 限制，汇点 $t$ 的流入量受 $c_t$ 限制）。</p><p>为了解决这种“点容量”模型的最大流问题，我们可以使用一种经典的转换技术：<strong>节点拆分法</strong>（node splitting）。该方法将每个节点拆分为两个部分，从而将节点容量转换为边容量，将问题转化为标准的最大流问题。下面我将详细描述算法设计、步骤，并解释其正确性。</p><p><strong>算法设计：最大流求解点容量模型</strong></p><p>算法的主要思想是将原始图 $G$ 转化为一个新图 $G’$，其中节点容量被表示为边容量。具体来说，每个节点 $i$ 被拆分成一个“输入节点” $i_{\\text{in}}$ 和一个“输出节点” $i_{\\text{out}}$，并在它们之间添加一条边，容量为 $c_i$。原始图中的边（容量无穷大）则在 $G’$ 中被转化为连接输出节点到输入节点的边。然后，在 $G’$ 上运行标准最大流算法（如 Dinic 算法或 Edmonds-Karp 算法）。</p><p><strong>输入</strong>：</p><ul><li>有向图 $G = (V, E)$，其中 $V$ 是节点集，$E$ 是边集。</li><li>源点 $s \\in V$，汇点 $t \\in V$。</li><li>每个节点 $i \\in V$ 的容量 $c_i &gt; 0$（包括源点和汇点）。</li></ul><p><strong>输出</strong>：</p><ul><li>最大流值（从源点 $s$ 到汇点 $t$ 的最大流量）。</li><li>（可选）流分配方案，即每条边上的流量值（注意：原始图中的边容量为无穷大，所以流分配仅需满足节点容量和流守恒）。</li></ul><p><strong>算法步骤</strong>：</p><ol><li><p><strong>构造新图 $G’$</strong>:</p><ul><li><p>对于每个节点 $i \\in V$</p><ul><li>在 $G’$ 中创建两个新节点：$i_{\\text{in}}$（输入节点）和 $i_{\\text{out}}$（输出节点）。</li><li>添加一条从 $i_{\\text{in}}$ 到 $i_{\\text{out}}$ 的有向边，容量为 $c_i$。这条边将节点容量限制转化为边容量。</li></ul></li><li><p>对于原始图中的每条边 $(u, v) \\in E$</p><ul><li>在 $G’$ 中，添加一条从 $u_{\\text{out}}$ 到 $v_{\\text{in}}$ 的有向边，容量设置为一个足够大的数（如 $\\sum_{i \\in V} c_i$，记为 $C_{\\text{sum}}$)，代表原始边的无穷大容量（实际中，使用 $C_{\\text{sum}}$ 已足够，因为最大流值不会超过节点容量之和）。</li></ul></li><li><p>设置 $G’$ 的源点为 $s_{\\text{in}}$（原始源点 $s$ 的输入节点）。</p></li><li><p>设置 $G’$ 的汇点为 $t_{\\text{out}}$（原始汇点 $t$ 的输出节点）。</p></li><li><p>（可选）如果图中有自环或多重边，处理方式相同（自环边 $(i, i)$ 会被转化为 $i_{\\text{out}} \\to i_{\\text{in}}$ 边，容量无限）。</p></li></ul></li><li><p><strong>在 $G’$ 上运行标准最大流算法</strong>:</p><ul><li>使用标准最大流算法（例如，Dinic 算法或 Ford-Fulkerson 的 Edmonds-Karp 实现）在 $G’$ 上计算从 $s_{\\text{in}}$ 到 $t_{\\text{out}}$ 的最大流。</li><li>算法输出：最大流值 $f_{\\text{max}}$，以及 $G’$ 中各条边上的流值。</li></ul></li><li><p><strong>恢复原始图的流分配</strong>:</p><ul><li>对于原始图中的每条边 $(u, v) \\in E$，其流值等于 $G’$ 中边 $(u_{\\text{out}}, v_{\\text{in}})$ 的流值（因为边容量无限，流值直接由节点容量约束）。</li><li>最大流值即为 $G’$ 中的最大流值 $f_{\\text{max}}$。</li><li>节点 $i$ 的总流量（流经该节点的流量）等于 $G’$ 中边 $(i_{\\text{in}}, i_{\\text{out}})$ 的流值（此值不超过 $c_i$，保证了节点容量约束）。</li></ul></li></ol><p><strong>复杂性分析</strong>：</p><ul><li>节点数：$G’$ 有 $2|V|$ 个节点（每个原始节点拆分为两个）。</li><li>边数：$G’$ 有 $|E| + |V|$ 条边（原始每条边对应一条新边，加上每个节点的新边）。</li><li>因此，图的大小为 $O(|V| + |E|)$，算法复杂性与标准最大流算法相同（如 Dinic 算法的 $O(|V|^2 |E|)$ 或 Edmonds-Karp 的 $O(|V| |E|^2)$）。转换过程是线性时间的，整体算法为多项式时间。</li></ul><h3>正确性解释</h3><p>节点拆分法的核心在于将节点容量转化为边容量，从而将点容量问题转化为标准最大流问题。以下通过三个方面证明正确性：<strong>可行性保持</strong>、<strong>容量约束保持</strong>和<strong>最优性保持</strong>。</p><h4>1. 可行性保持（原始图可行流对应 $G’$ 可行流）</h4><ul><li><p>假设原始图 $G$ 中存在一个可行流 $f$，满足所有节点容量约束（即对于每个节点 $i$，流经 $i$ 的总流量 $\\leq c_i$）和流守恒（对于中间节点，流入等于流出；对于源点，只有流出；对于汇点，只有流入）。</p></li><li><p>在 $ G’ $ 中构造流 $ f’ $ ：</p><ul><li>对于每个节点 $i$，设 $i_{\\text{in}} \\to i_{\\text{out}}$ 边的流值为流经原始节点 $i$ 的总流量（由于节点容量约束，此值 $\\leq c_i$）。</li><li>对于原始边 $(u, v)$，设 $u_{\\text{out}} \\to v_{\\text{in}}$ 边的流值为 $f(u, v)$（因为边容量无限，流值不被限制）。</li></ul></li><li><p>流守恒在 $ G’ $ 中自动满足：</p><ul><li>在 $i_{\\text{in}}$：只有输入边和输出边到 $i_{\\text{out}}$，因此进入 $i_{\\text{in}}$ 的总流量（来自其他节点的输出节点）等于流出到 $i_{\\text{out}}$ 的流量（因为 $i_{\\text{in}} \\to i_{\\text{out}}$ 是唯一输出边）。</li><li>在 $i_{\\text{out}}$：只有输入边来自 $i_{\\text{in}}$ 和输出边到其他节点的输入节点，因此流入等于流出。</li><li>源点 $s_{\\text{in}}$ 没有输入边（是 $G’$ 的源），输出到 $s_{\\text{out}}$ 的流量受 $c_s$ 限制，对应原始源点流出。</li><li>汇点 $t_{\\text{out}}$ 没有输出边（是 $G’$ 的汇），输入来自 $t_{\\text{in}}$，流量受 $c_t$ 限制。</li></ul></li><li><p>因此，$f’$ 是 $G’$ 的可行流，且流值等于原始流值。</p></li></ul><h4>2. 容量约束保持（点容量约束等价于拆分边容量）</h4><ul><li>在原始图中，节点容量约束要求流经节点 $i$ 的总流量 $\\leq c_i$。</li><li>在 $G’$ 中，边 $i_{\\text{in}} \\to i_{\\text{out}}$ 的容量为 $c_i$。无论流量如何通过其他边进入 $i_{\\text{in}}$ 或从 $i_{\\text{out}}$ 流出，流量必须经过此边，因此其流值（即流经节点 $i$ 的流量）不超过 $c_i$。</li><li>原始图的无限边容量在 $G’$ 中由无限容量的边（或大容量边 $u_{\\text{out}} \\to v_{\\text{in}}$）处理，不限制流量。</li><li>因此，任何 $G’$ 的可行流对应于原始图的可行流，满足所有节点容量约束。</li></ul><h4>3. 最优性保持（最大流值等价）</h4><ul><li><p>由于转换是双射的（bijective），原始图的任何可行流对应 $G’$ 的一个可行流，反之亦然。</p></li><li><p>最大流值相同：原始图的最大流值等于 $ G’ $ 中从 $ s_{\\text{in}} $ 到 $ t_{\\text{out}} $ 的最大流值。</p><ul><li>这是因为： <ul><li>流值定义为源点到汇点的总流量。</li><li>在原始图中，源点 $s$ 的总流出量等于在 $G’$ 中 $s_{\\text{in}} \\to s_{\\text{out}}$ 的流值（受 $c_s$ 限制）。</li><li>在 $G’$ 中，最大流算法会最大化从 $s_{\\text{in}}$ 到 $t_{\\text{out}}$ 的流，同时受限于所有 $i_{\\text{in}} \\to i_{\\text{out}}$ 的容量 $c_i$，这正好对应了原始问题中最大化流量的同时满足节点容量约束。</li></ul></li></ul></li><li><p>标准最大流算法（如 Dinic）在 $G’$ 上保证找到最大流，因此也得到原问题的最大流。</p></li></ul><h3>例子说明</h3><p>考虑一个简单例子：图中有节点 $V = {s, a, t}$，边 $E = {(s, a), (a, t)}$，节点容量 $c_s = 2, c_a = 3, c_t = 2$（边容量无穷大）。</p><ul><li><strong>原始图</strong>： <ul><li>节点：s（源点）、a（中间点）、t（汇点）。</li><li>边：(s, a) 和 (a, t)，容量无穷大。</li><li>约束：s 的总流出 ≤ 2，a 的总流量 ≤ 3，t 的总流入 ≤ 2。</li></ul></li><li><strong>构造 G’</strong>： <ul><li>创建节点：s_in, s_out, a_in, a_out, t_in, t_out。</li><li>添加节点边：s_in → s_out（容量 2），a_in → a_out（容量 3），t_in → t_out（容量 2）。</li><li>添加原始边对应：s_out → a_in（容量 ∞），a_out → t_in（容量 ∞）。</li><li>源点为 s_in，汇点为 t_out。</li></ul></li><li><strong>在 G’ 上运行最大流算法</strong>： <ul><li>最大流可能为 2（因为 s_in → s_out 容量 2，且 t_in → t_out 容量 2）。</li><li>例如，流量：s_in → s_out 流值 2，s_out → a_in 流值 2，a_in → a_out 流值 2，a_out → t_in 流值 2，t_in → t_out 流值 2。</li><li>恢复原始流：(s, a) 流值 2，(a, t) 流值 2，满足节点容量（s 流出 2，a 流量 2，t 流入 2）。</li></ul></li><li><strong>若节点容量更大</strong>，例如 c_a = 4，则最大流可达 2（受限 c_s 和 c_t）。</li></ul><h3>实现注意事项</h3><ul><li><strong>无穷大容量处理</strong>：在代码中，边 $(u_{\\text{out}}, v_{\\text{in}})$ 的容量设置为一个大数（如所有 $c_i$ 之和），以避免无穷大带来的问题。理论中不影响正确性。</li><li><strong>算法选择</strong>：推荐使用高效的最大流算法，如 Dinic 算法（复杂度 $O(|V|^2 |E|)$），尤其当图较大时。</li><li><strong>扩展性</strong>：该方法也适用于无向图（将无向边转为两个有向边）和多源多汇问题（添加超级源和超级汇）。</li><li><strong>代码实现</strong>：在 Python 中，可使用 NetworkX 库或自定义实现（例如，基于 BFS 的增广路径搜索）。</li></ul><p>这个算法高效且正确，能将点容量问题转化为标准最大流问题求解。任何标准最大流算法的正确性基础（如最大流最小割定理）在 $G’$ 上仍适用，从而确保整个方法的正确性。</p><hr><h2>6</h2><p>问题描述</p><p>某工厂需要采购 K 种零件$j \\in [K]$，每种零件 j 的日需求量为$ d_j$。有 m 家供应商$i \\in [m]$，第 i 家供应商提供零件 j 的单位价格为 $a_{ij}$，且最多供应 $c_{ij}$ 个零件 j。目标是设计一个算法，求解最小化总采购成本的问题，并确保满足所有零件需求。如果总供应能力无法满足所有需求，算法应报告问题不可行。</p><p>算法设计</p><p>由于每个零件的采购决策相互独立（即，供应商对每种零件的供应能力 $c_{ij} $是独立的，没有共享的总供应约束），问题可以分解为 K 个独立的子问题，每个子问题针对一种零件 j，求解最小采购成本以满足需求 $d_j$。对于每个零件 j，最小成本子问题可以通过贪心策略求解：按单位价格 $a_{ij} $从低到高排序供应商，并从最低价格的供应商开始采购，直到满足需求 $d_j$。</p><p>算法步骤 初始化总成本：设 total_cost = 0。</p><p>遍历每种零件：对于每个零件$ j \\in [K]$ 执行以下步骤：</p><p>检查需求：如果 $d_j $= 0（即该零件无需求），则跳过当前零件（成本为 0）。</p><p>构建可用供应商列表：收集所有能提供零件 j 的供应商，即 $c_{ij} $&gt; 0 的供应商。列表元素为元组 $i, a_{ij}, c_{ij}$，其中 i 是供应商索引。</p><p>检查可行性：如果列表为空（无供应商能提供零件 j）且 $d_j $&gt; 0，则问题不可行，算法输出“不可行”并终止。</p><p>排序供应商：对可用供应商列表按单位价格 $a_{ij} $升序排序（即价格从低到高）。</p><p>贪心采购：</p><p>设剩余需求 rem = $d_j$ 和当前零件成本$ cost_j$ = 0。</p><p>遍历排序后的供应商列表（从最低价格开始）：</p><p>计算可采购量：amount = min(rem,$ c_{ij}$)。</p><p>更新成本：$cost_j $+= amount * $a_{ij}$。</p><p>更新剩余需求：rem -= amount。</p><p>如果 rem == 0，则需求满足，跳出循环。</p><p>如果遍历结束后 rem &gt; 0（即所有供应商的总供应能力不足），则问题不可行，输出“不可行”并终止。</p><p>累加总成本：如果需求满足，total_cost += $cost_j$。 输出结果：如果所有零件需求均满足，输出 total_cost 作为最小总采购成本。</p><p>时间复杂度 对于每个零件 j，构建供应商列表的时间为 O(m)（遍历所有供应商）。</p><p>对供应商排序的时间为 O($m \\log m$)（使用快速排序或归并排序）。</p><p>贪心采购的扫描时间为 O(m)。</p><p>因此，处理一个零件 j 的总时间为 O($m + m \\log m$) = O($m \\log m$)。</p><p>对于所有 K 个零件，总时间为 O($K \\cdot m \\log m$)。</p><p>输入大小为 O($K m$)（每个供应商-零件对有价格和容量），因此算法是输入大小的多项式时间。</p><p>空间复杂度 空间主要用于存储输入数据和中间列表。每个零件 j 的供应商列表最多有 m 个元素，因此额外空间为 O($K m$)。</p><p>总体空间复杂度为 O($K m$)，与输入大小相同。</p><p>正确性解释</p><p>算法正确性基于以下两个关键点：子问题独立性和贪心策略最优性。 子问题独立性：</p><p>约束分析：供应商的供应能力$ c_{ij}$ 是特定于零件 j 的（即每个零件的供应决策不共享任何约束）。零件之间无耦合，因此总最小成本等于每个零件 j 的最小成本之和。</p><p>可行性：如果所有零件 j 的需求都能独立满足，则整个问题可行；否则，任意零件 j 无法满足需求会导致整体不可行。算法在遍历零件时立即检查可行性。 贪心策略最优性（针对单个零件 j）：</p><p>问题模型：对于固定零件 j，问题可建模为：最小化$ \\sum_{i} a_{ij} x_{ij}$，满足 $\\sum_{i} x_{ij} \\geq d_j$ 且 $0 \\leq x_{ij} \\leq c_{ij}$。其中，$x_{ij}$ 是从供应商 i 采购零件 j 的数量。</p><p>贪心选择：将供应商按 $a_{ij} $升序排序，并优先从最低价格供应商采购最大可能量（即尽可能使用$ c_{ij}$），直到满足需求 $d_j$。</p><p>最优性证明（反证法）：</p><p>假设存在一个更优解（成本更低），其中某个高价格供应商（如$ a_{i_2 j} &gt; a_{i_1 j}$）被优先使用，而低价格供应商 i_1 未被充分利用（即 $x_{i_1 j} &lt; c_{i_1 j}$）。</p><p>则可以通过减少高价格供应商的采购量，增加低价格供应商的采购量（因为 $a_{i_2 j} &gt; a_{i_1 j}$），构造一个新解：设$ \\delta = \\min(c_{i_1 j} - x_{i_1 j}, x_{i_2 j}) &gt; 0$，更新$ x_{i_1 j} = x_{i_1 j} + \\delta$ 和 $x_{i_2 j} = x_{i_2 j} - \\delta$。</p><p>新解的成本变化为 $\\delta \\cdot (a_{i_1 j} - a_{i_2 j}) &lt; 0$（因为$ a_{i_1 j} &lt; a_{i_2 j}$），成本降低，与原解“更优”矛盾。</p><p>因此，任何不从最低价格供应商优先采购的策略都不是最优。贪心策略（按价格排序并顺序采购）确保了局部最优，且由于问题结构简单（线性目标函数和独立容量约束），局部最优即为全局最优。</p><p>需求满足：贪心扫描确保在供应商排序后充分利用低价资源；如果排序后总供应能力小于 $d_j$，则问题不可行。</p><p>综上，该算法高效地求解了最小采购成本问题，并保证正确性。实际实现中，若参数均为整数，采购量 $x_{ij} $自然为整数；若需求$ d_j$ 或容量$ c_{ij}$ 为实数，算法同样适用。</p><hr><h2>7</h2><p><strong>König 定理</strong>指出：在任意二分图中，最大匹配数 = 最小顶点覆盖数。该结论源于线性规划对偶性，也可用网络流模型证明。</p><p>该等价性带来实际算法优势：</p><ul><li>使用 Hopcroft–Karp 算法在 $O(E\\sqrt{V})$ 时间内找到最大匹配；</li><li>再用可达标记法构造最小顶点覆盖。</li></ul><p>因此，二分图的最小顶点覆盖可在多项式时间内高效求解。</p>',147)])))}};export{x as category,s as date,m as default,c as summary,u as updated};
