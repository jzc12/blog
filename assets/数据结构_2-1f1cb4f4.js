import{o,c as p,a as c}from"./index-0f6a4c8e.js";const a="/blog/assets/树基本概念-5c5f0b03.png",l="/blog/assets/树的性质1-ae1cfddd.png",g="/blog/assets/树的性质2-7f4a00ec.png",e="/blog/assets/二叉树-451ceabd.png",r="/blog/assets/满二叉树-17e6de6c.png",n="/blog/assets/二叉排序树-b0daed0a.png",i="/blog/assets/平衡二叉树-78a09021.png",b="/blog/assets/中序线索化-237ae42a.png",m="/blog/assets/先序线索化-67298d14.png",_="/blog/assets/森林-53c5dee0.png",h="/blog/assets/带权路径-e47e8e07.png",u="/blog/assets/哈夫曼树1-519d8fb8.png",k="/blog/assets/哈夫曼编码-714175ac.png",d="/blog/assets/双亲表示法-73c3e161.png",q="/blog/assets/并查集-f11b763b.png",f="/blog/assets/Union优化-e266c204.png",F="/blog/assets/Find优化-0534a7cd.png",S="/blog/assets/并查集复杂度分析-047c1675.png",D="/blog/assets/图的基本概念-154285d5.png",y="/blog/assets/图的存储方式-76ce2fba.png",B="/blog/assets/邻接矩阵-fb58707c.png",A="/blog/assets/邻接矩阵性质-bda57886.png",T="/blog/assets/邻接表-99cc3498.png",Z="/blog/assets/邻接表和邻接矩阵-189200fa.png",$="/blog/assets/邻接多重表-89bccaec.png",j="/blog/assets/十字链表法-baff41bf.png",w="/blog/assets/BFS算法-fc747fcf.png",x="/blog/assets/BFS复杂度分析-65acfb41.png",G="/blog/assets/DFS算法-d761ed6c.png",K="/blog/assets/DFS时间复杂度-ee831a60.png",O="/blog/assets/DFS空间复杂度-7589c8da.png",U="/blog/assets/普里姆算法-7b3d631e.png",V="/blog/assets/Kruskal算法-66b29fec.png",E="/blog/assets/最小生成树-3d858776.png",P="/blog/assets/Dijkstra算法-a9ea36c5.png",v="/blog/assets/Floyd算法-4348bffd.png",N="/blog/assets/最短路径-5d3a2f0b.png",z="/blog/assets/DAG-cb4aa8ff.png",C="/blog/assets/拓扑排序-9d0a2a9e.png",H="/blog/assets/拓扑排序代码-f6572bd1.png",I="/blog/assets/逆拓扑排序-9779e02a.png",J="/blog/assets/逆拓扑排代码-f5a50e83.png",L="/blog/assets/关键路径-4475fecb.png",M="/blog/assets/关键路径定义-fc230bb0.png",Q="/blog/assets/最早发生时间-6d408974.png",R="/blog/assets/最迟发生时间-82e9d21d.png",W="/blog/assets/活动最早发生时间-c678f4e5.png",X="/blog/assets/活动最迟发生时间-e031684c.png",Y="/blog/assets/活动时间余量-cf6b9e3d.png",ss={class:"markdown-body"},as="2025-10-07T00:00:00.000Z",ls="2025-10-07T00:00:00.000Z",gs="考研复习",es="数据结构5树与二叉树6图",rs={__name:"数据结构_2",setup(ts,{expose:t}){return t({frontmatter:{date:"2025-10-07T00:00:00.000Z",updated:"2025-10-07T00:00:00.000Z",category:"考研复习",summary:"数据结构5树与二叉树6图"}}),(ps,s)=>(o(),p("div",ss,s[0]||(s[0]=[c('<h2>5.树</h2><p><img src="'+a+'" alt="树基本概念"></p><p><img src="'+l+'" alt="树的性质1"></p><p><img src="'+g+'" alt="树的性质2"></p><h3>二叉树</h3><h4>定义</h4><p><img src="'+e+'" alt="二叉树"></p><h4>满二叉树、完全二叉树</h4><p><img src="'+r+'" alt="满二叉树"></p><h4>二叉排序树</h4><p><img src="'+n+'" alt="二叉排序树"></p><h4>平衡二叉树</h4><p><img src="'+i+'" alt="平衡二叉树"></p><h4>正则二叉树</h4><blockquote><p>二叉树前序、中序、后序遍历</p></blockquote><h4>线索二叉树</h4><blockquote><p>中序线索化</p></blockquote><p><img src="'+b+'" alt="中序线索化"></p><blockquote><p>先序线索化</p></blockquote><p><img src="'+m+'" alt="先序线索化"></p><h3>树、森林</h3><p><img src="'+_+'" alt="森林"></p><h3>树的应用</h3><h4>哈夫曼树</h4><p><img src="'+h+'" alt="带权路径"></p><blockquote><p>加权平均长度 = $\\frac{\\displaystyle\\sum_{i=1}^n w_i * l_i}{\\displaystyle\\sum_{i=1}^n w_i}$</p></blockquote><p><img src="'+u+'" alt="哈夫曼树1"></p><blockquote><p>哈夫曼编码集和定长编码集</p></blockquote><p><img src="'+k+'" alt="哈夫曼编码"></p><h4>并查集</h4><p><img src="'+d+'" alt="双亲表示法"></p><blockquote><p>基本并查集</p><p>优化的思路都是尽可能让树变矮</p></blockquote><p><img src="'+q+'" alt="并查集"></p><blockquote><p>Union优化</p></blockquote><p><img src="'+f+'" alt="Union优化"></p><blockquote><p>Find 优化 路径压缩</p><p>第一次循环找到根节点、第二次循环将查找路径下的节点直接挂在在根结点下</p></blockquote><p><img src="'+F+'" alt="Find优化"></p><p><img src="'+S+'" alt="并查集复杂度分析"></p><h2>6.图</h2><h3>基本概念</h3><p><img src="'+D+'" alt="图的基本概念"></p><h3>图的存储</h3><p><img src="'+y+'" alt="图的存储方式"></p><h4>邻接矩阵</h4><p><img src="'+B+'" alt="邻接矩阵"></p><blockquote><p>有权图更改表中数值即可</p></blockquote><p><img src="'+A+'" alt="邻接矩阵性质"></p><h4>邻接表</h4><p><img src="'+T+'" alt="邻接表"></p><p><img src="'+Z+'" alt="邻接表和邻接矩阵"></p><h4>邻接多重表</h4><p><img src="'+$+'" alt="邻接多重表"></p><h4>十字链表</h4><p><img src="'+j+'" alt="十字链表法"></p><h3>图的遍历</h3><h4>BFS</h4><p><img src="'+w+'" alt="BFS算法"></p><p><img src="'+x+'" alt="BFS复杂度分析"></p><blockquote><p>广度优先生成树、广度优先生成森林</p></blockquote><h4>DFS</h4><p><img src="'+G+'" alt="DFS算法"></p><blockquote><p>复杂度分析</p></blockquote><p><img src="'+K+'" alt="DFS时间复杂度"></p><p><img src="'+O+'" alt="DFS空间复杂度"></p><blockquote><p>深度优先生成树</p></blockquote><h3>最小生成树</h3><h4>Prim普里姆算法</h4><blockquote><p>图示</p></blockquote><p><img src="'+U+'" alt="普里姆算法"></p><h4>Kruskal算法</h4><p><img src="'+V+'" alt="Kruskal算法"></p><blockquote><p>时间度、复杂度分析</p></blockquote><p><img src="'+E+'" alt="最小生成树"></p><h3>最短路径</h3><blockquote><p>单源最短路径、每对顶点最短路径</p></blockquote><h4>Dijkstra算法</h4><p><img src="'+P+'" alt="Dijkstra算法"></p><blockquote><p>时间复杂度 $O(|V|^2)$</p><p>类似Prim算法，每次找最短的那个节点，从这个结点出发，更新这一轮的最小距离</p><p>BFS 也能使用，但是要求权值都相同</p></blockquote><h4>Floyd算法</h4><p><img src="'+v+'" alt="Floyd算法"></p><p><img src="'+N+'" alt="最短路径"></p><blockquote><p>BFS的时间复杂度：邻接表、邻接矩阵</p></blockquote><h3>有向无环图</h3><blockquote><p>DAG：分层、化简</p></blockquote><p><img src="'+z+'" alt="DAG"></p><h3>拓扑排序</h3><blockquote><p>AOV网</p></blockquote><h4>拓扑排序</h4><p><img src="'+C+'" alt="拓扑排序"></p><p><img src="'+H+'" alt="拓扑排序代码"></p><h4>逆拓扑排序</h4><p><img src="'+I+'" alt="逆拓扑排序"></p><p><img src="'+J+'" alt="逆拓扑排代码"></p><h3>关键路径</h3><blockquote><p>AOE网</p></blockquote><p><img src="'+L+'" alt="关键路径"></p><p><img src="'+M+'" alt="关键路径定义"></p><h4>事件最早发生时间</h4><p><img src="'+Q+'" alt="最早发生时间"></p><h4>事件最迟发生时间</h4><p><img src="'+R+'" alt="最迟发生时间"></p><blockquote><p>活动对应计算</p></blockquote><h4>活动最早发生时间</h4><p><img src="'+W+'" alt="活动最早发生时间"></p><h4>活动最迟发生时间</h4><p><img src="'+X+'" alt="活动最迟发生时间"></p><h4>活动时间余量</h4><p><img src="'+Y+'" alt="活动时间余量"></p>',108)])))}};export{gs as category,as as date,rs as default,es as summary,ls as updated};
