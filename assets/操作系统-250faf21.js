import{o as s,c as p,a as r}from"./index-fb3d2949.js";const n="/blog/assets/系统调用-266958a9.jpg",g="/blog/assets/进程状态-44811026.png",l="/blog/assets/线程实现方式-a19d52ef.png",e="/blog/assets/线程-内核-616ebe3f.png",h="/blog/assets/CPU调度-b845affa.png",c="/blog/assets/调度时机-56b259af.png",i="/blog/assets/临界区-53e3c7dd.png",a="/blog/assets/进程同步-c73b1c78.png",d="/blog/assets/进程互斥-7d436b7d.png",b="/blog/assets/互斥1-8312ec34.png",u="/blog/assets/互斥2-ad24239c.png",k="/blog/assets/单标志法-63a6ebee.png",m="/blog/assets/内存管理的概念-b227eeaf.png",C="/blog/assets/进程的内存映像-8ec18b8c.png",P="/blog/assets/覆盖技术-a7c17a09.png",q="/blog/assets/交换技术-4d85e529.png",B="/blog/assets/内存连续分配-779b7687.png",_={class:"markdown-body"},I="2025-07-01T00:00:00.000Z",D="2025-07-27T00:00:00.000Z",x="考研复习",A="操作系统",E={__name:"操作系统",setup(U,{expose:o}){return o({frontmatter:{date:"2025-07-01T00:00:00.000Z",updated:"2025-07-27T00:00:00.000Z",category:"考研复习",summary:"操作系统"}}),(y,t)=>(s(),p("div",_,t[0]||(t[0]=[r(`<h1>第一章 计算机系统概述</h1><blockquote><p><strong>需要弄清楚，暂时，笔记不是为了笔记而记</strong></p></blockquote><h2>1.1 操作系统的基本概念</h2><h2>1.2 发展历程</h2><h2>1.3 运行的环境</h2><blockquote><p>特权指令</p><p>非特权指令</p></blockquote><h3>3.1 内核操作</h3><ol><li>时钟管理</li><li>中断机制</li><li>原语</li><li>系统控制的数据结构及处理</li></ol><h3>3.2 中断和异常的概念</h3><ol><li>定义</li></ol><pre><code class="language-mermaid">graph LR
    A[中断] --&gt; B[内部异常]
    A --&gt; C[外部中断（硬件）]
    B --&gt; D[故障（Fault）] --&gt; G[软件中断]
    B --&gt; E[自陷（Trap）] --&gt; H[软件中断]
    B --&gt; F[终止（Abort）] --&gt; I[硬件中断]
    C --&gt; J[可屏蔽中断 INTR]
    C --&gt; K[不可屏蔽中断 NMI]
</code></pre><p>访管指令 – trap 指令</p><ol start="2"><li>处理过程</li></ol><pre><code class="language-mermaid">flowchart LR
    A[CPU执行用户程序第i条指令] --&gt; B{检测到异常事件\\n或中断请求信号?}
    B -- 是 --&gt; C[打断当前程序]
    C --&gt; D[转至中断/异常处理程序]
    D --&gt; E{问题可解决?}
    E -- 是 --&gt; F[执行中断返回指令]
    F --&gt; G[返回用户程序\\n第i或i+1条指令]
    E -- 否 --&gt; H[终止用户程序]
    B -- 否 --&gt; A

    classDef decision fill:#f8f9fa,stroke:#495057,stroke-width:2px
    classDef process fill:#e9f5ff,stroke:#228be6
    class B,E decision
    class A,C,D,F,G,H proces
</code></pre><h3>3.3 系统调用</h3><ol><li>按功能分类</li></ol><blockquote><p>设备管理</p><p>文件管理</p><p>进程控制</p><p>进程通信</p><p>内存管理</p></blockquote><ol start="2"><li>处理过程</li></ol><img src="`+n+'" alt="系统调用" style="zoom:25%;"><h2>1.4 操作系统结构</h2><h3>4.1 分层法</h3><p>优点：</p><p>问题：</p><h3>4.2 模块化</h3><h3>4.3 宏内核</h3><h3>4.4 微内核</h3><h3>4.5 外核</h3><h2>1.5 操作系统引导</h2><p><strong>1. 激活CPU</strong></p><p><strong>2. 硬件自检</strong></p><p><strong>3. 加载带有操作系统的硬盘</strong></p><p><strong>4. 加载主引导记录 MBR</strong></p><p><strong>5. 扫描硬盘分区表</strong></p><p><strong>6. 加载分区引导记录 PBR</strong></p><p><strong>7. 加载启动管理器</strong></p><p><strong>8. 加载操作系统</strong></p><h2>1.6 虚拟机</h2><h1>第二章 进程 &amp; 线程</h1><h2>2.1 进程</h2><h3>1.1 基本概念</h3><blockquote><p><strong>目的</strong>： 为允许多个程序并发执行、更好的描述和控制程序的并发执行，实现操作系统的并发性和共享性。</p></blockquote><blockquote><p><strong>PCB （Process Control Block）</strong>: 进程控制块，描述进程的基本情况和运行状态，进而控制和管理进程</p></blockquote><blockquote><p>进程是一个程序及其数据从磁盘加载到内存后，在CPU上的执行过程； <strong>是系统进行资源分配和调度的基本单位</strong></p></blockquote><p>特征（理解）：动态、并发、独立、异步</p><h3>1.2 进程的组成</h3><h4>PCB</h4><blockquote><ol><li>进程创建时，操作系统为它新建一个PCB，该结构之后常驻内存，任何时刻都可以存取，并在进程结束时删除。 PCB是进程实体的一部分，是进程存在的唯一标志。</li><li>进程执行时，系统通过其 PCB了解进程的现行状态信息，以便操作系统对其进行控制和管理；进程结束时，系统收回其PCB，该进程随之消亡。</li><li>当操作系统希望调度某个进程运行时，要从该进程的PCB中查出其现行状态及优先级；在调度到某个进程后，要根据其PCB中所保存的CPU状态信息，设置该进程恢复运行的现场，并根据其PCB中的程序和数据的内存始址，找到其程序和数据；进程在运行过程中，当需要和与之合作的进程实现同步、通信或访问文件时，也需要访问PCB；当进程由于某种原因此暂停运行时，又需将其断点的 CPU环境保存在PCB中。可见，在进程的整个生命期中，系统总是通过PCB对进程进行控制的，亦即系统唯有通过进程的PCB才能感知到该进程的存在。</li></ol></blockquote><p><strong>PCB通常包含的内容</strong></p><table><thead><tr><th>进程描述信息</th><th>进程控制和管理信息</th><th>资源分配清单</th><th>处理机相关信息</th></tr></thead><tbody><tr><td>进程标识符(PID)</td><td>进程当前状态</td><td>代码段指针</td><td>通用寄存器值</td></tr><tr><td>用户标识符(UID)</td><td>进程优先级</td><td>数据段指针</td><td>地址寄存器值</td></tr><tr><td></td><td>代码运行入口地址</td><td>堆栈段指针</td><td>控制寄存器值</td></tr><tr><td></td><td>程序的外存地址</td><td>文件描述符</td><td>标志寄存器值</td></tr><tr><td></td><td>进入内存时间</td><td>键盘</td><td>状态字</td></tr><tr><td></td><td>CPU占用时间</td><td>鼠标</td><td></td></tr><tr><td></td><td>信号量使用</td><td></td><td></td></tr></tbody></table><p><strong>PCB组织方式</strong></p><blockquote><p>链接</p><p>索引</p></blockquote><h4>程序段</h4><h4>数据段</h4><h3>1.3 进程的状态与转换</h3><p><img src="'+g+`" alt="进程状态"></p><h3>1.4 进程控制</h3><blockquote><p>操作系统中，一般将进程控制用的程序程称为原语（不允许终端、不允许分割）。</p></blockquote><h4>进程的创建</h4><p><strong>进程与子进程的关系和特点（2020）</strong> 允许一个进程创建另一个进程，此时创建者称为父进程，被创建的进程称为子进程。子进程可以继承父进程所拥有的资源。当子进程被撤销时，应将其从父进程那里获得的资源还给父进程。此外，在撤销父进程时，通常也会同时撤销其所有的子进程。</p><p><strong>导致创建进程的操作（2010）</strong> 在操作系统中，<strong>终端用户登录系统、作业调度、系统提供服务、用户程序的应用请求</strong>等都会引起进程的创建。操作系统创建一个新进程的过程如下（创建原语）：</p><p><strong>创建新进程时的操作（2021）</strong></p><ol><li>分配一个唯一的进程标识号，并申请空白PCB（PCB有限）。若PCB申请失败，则创建失败。</li><li>为进程分配所需资源（内存、文件、I/O设备、CPU时间等，在PCB中体现）。资源可从操作系统或父进程获得；若资源不足（如内存），进程进入<strong>创建态</strong>等待资源，不立即失败。</li><li>初始化PCB：包括 <ul><li>初始化标志信息</li><li>初始化CPU状态信息</li><li>初始化CPU控制信息</li><li>设置进程优先级等</li></ul></li><li><strong>加入就绪队列</strong>：若就绪队列可接纳新进程，则将其插入队列，等待调度运行。</li></ol><h4>进程的终止</h4><p>**引起进程终止的事件主要有：</p><p>① <strong>正常结束</strong>：进程任务完成，准备退出运行。</p><p>② <strong>异常结束</strong>：进程运行时发生异常事件导致无法继续运行，包括：</p><blockquote><p>存储区越界、保护错、非法指令、特权指令错、运行超时、算术运算错、I/O故障</p></blockquote><p>③ <strong>外界干预</strong>：进程因外部请求终止，例如：</p><blockquote><p>操作员或操作系统干预、父进程请求、父进程终止</p></blockquote><p><strong>操作系统终止进程的过程如下（终止原语）：</strong></p><p><strong>1)</strong> 根据被终止进程的标识符，检索出该进程的PCB，从中读出该进程的状态。</p><p><strong>2)</strong> 若被终止进程处于运行状态，立即终止该进程的执行，将CPU资源分配给其他进程。</p><p><strong>3)</strong> 若该进程还有子孙进程，则通常需将其所有子孙进程终止（<strong>注：有些系统无此要求</strong>)。</p><p><strong>4)</strong> 将该进程所拥有的全部资源，<strong>或归还给其父进程</strong>，<strong>或归还给操作系统</strong>。</p><p><strong>5)</strong> 将该PCB从所在队列(链表)中删除。</p><blockquote><p><strong>级联终止补充说明</strong> 有些系统不允许子进程在父进程终止的情况下存在，对于这类系统，若一个进程终止，则它的所有子进程也终止，这种现象称为<strong>级联终止</strong>。然而，<strong>不是所有操作系统都是这么设计的</strong>。</p></blockquote><h4>进程的阻塞和唤醒</h4><p><strong>进程阻塞的事件与时机（2018、2022、2023）</strong> 正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新任务可做等，进程便通过调用阻塞原语（Block），使自己由<strong>运行态</strong>变为<strong>阻塞态</strong>。可见，阻塞是进程自身的一种<strong>主动行为</strong>，也因此只有处于<strong>运行态</strong>的进程（获得CPU），才可能将其转为阻塞态。 <strong>阻塞原语的执行过程如下</strong>:</p><ol><li>找到将要被阻塞进程的标识号（PID）对应的PCB。</li><li>若该进程为运行态，则保护其现场，将其状态转为阻塞态，停止运行。</li><li>将该PCB插入相应事件的等待队列，将CPU资源调度给其他就绪进程。</li></ol><p><strong>进程唤醒的事件与时机（2014、2019）</strong> 当被阻塞进程所期待的事件出现时，如它所期待的I/O操作已完成或其所期待的数据已到达，由有关进程（例如：释放该I/O设备的进程，或提供数据的进程）调用唤醒原语（Wakeup），将等待该事件的进程唤醒。 <strong>唤醒原语的执行过程如下</strong>:</p><ol><li>在该事件的等待队列中找到相应进程的PCB。</li><li>将其从等待队列中移出，并置其状态为<strong>就绪态</strong>。</li><li>将该PCB插入就绪队列，等待调度程序调度。</li></ol><blockquote><p><strong>Block原语和Wakeup原语是一对作用刚好相反的原语，必须成对使用</strong>。</p><ul><li>若在某个进程中调用了Block原语，则必须在<strong>与之合作的进程</strong>或<strong>其他相关进程</strong>中安排对应的Wakeup原语；</li><li>否则，被阻塞进程将永久处于阻塞态。</li></ul></blockquote><h3>1.5 进程的通信</h3><h4>共享存储</h4><h4>消息传递</h4><h4>管道通信</h4><pre><code>管道是一个特殊的共享文件，又称pipe文件，数据在管道中是先进先出的。管道通信允许两个进程按生产者-消费者方式进行通信(见图2.4)，只要管道不满，写进程就能向管道的一端写入数据；只要管道非空，读进程就能从管道的一端读出数据。为了协调双方的通信，管道机制必须提供三方面的协调能力：①互斥，指当一个进程对管道进行读/写操作时，其他进程必须等待。②同步，指写进程向管道写入一定数量的数据后，写进程阻塞，直到读进程取走数据后再将它唤醒；读进程将管道中的数据取空后，读进程阻塞，直到写进程将数据写入管道后才将其唤醒。③确定对方的存在。
</code></pre><p>在Linux中，管道是一种使用非常频繁的通信机制。从本质上说，管道也是一种文件，但它又和一般的文件有所不同，管道可以克服使用文件进行通信的两个问题，具体表现如下：</p><p>1)限制管道的大小。管道文件是一个固定大小的缓冲区，在Linux中该缓冲区的大小为4KB，这使得它的大小不像普通文件那样不加检验地增长。使用单个固定缓冲区也会带来问题，比如在写管道时可能变满，这种情况发生时，随后对管道的write()调用将默认地被阻塞，等待某些数据被读取，以便腾出足够的空间供write()调用。</p><p>2)读进程也可能工作得比写进程快。当管道内的数据已被读取时，管道变空。当这种情况发生时，一个随后的read()调用将被阻塞，等待某些数据的写入。 管道只能由创建进程所访问，当父进程创建一个管道后，由于管道是一种特殊文件，子进程会继承父进程的打开文件，因此子进程也继承父进程的管道，并可用它来与父进程进行通信。</p><p><strong>注意</strong> 从管道读数据是一次性操作，数据一旦被读取，就释放空间以便写更多数据。普通管道只允许单向通信，若要实现两个进程双向通信，则需要定义两个管道。</p><h4>信号</h4><h2>2.2 线程</h2><h3>2.1 基本概念</h3><blockquote><p>线程是进程中的实体，是被系统独立调度和分派的基本单位</p></blockquote><p>引入进程的目的是更好地使多道程序并发执行，提高资源利用率和系统吞吐量；</p><p>而引入线程(Threads)的目的则是<strong>减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能</strong>。</p><p>线程由<strong>线程ID、程序计数器、寄存器集合和堆栈</strong>组成。线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。</p><p><strong>线程 &amp; 进程</strong></p><h3>2.2 线程的状态</h3><blockquote><p><strong>执行态</strong>：线程已获得CPU而正在运行。 <strong>就绪态</strong>：线程已具备各种执行条件，只需再获得CPU便可立即执行。 <strong>阻塞态</strong>：线程在执行中因某事件受阻而处于暂停状态。</p></blockquote><h3>2.3 线程的组织与控制</h3><p>1）</p><blockquote><p><strong>TCB （Thread Control Block）：</strong></p><p>① <strong>线程标识符</strong>； ② <strong>一组寄存器</strong>：包括程序计数器、状态寄存器和通用寄存器； ③ <strong>线程运行状态</strong>：用于描述线程正处于何种状态； ④ <strong>优先级</strong>： ⑤ <strong>线程专有存储区</strong>：线程切换时用于保存现场等； ⑥ <strong>堆栈指针</strong>：用于过程调用时保存局部变量及返回地址等。</p></blockquote><p>2）线程的创建</p><p>线程也是具有生命期的，它由创建而产生，由调度而执行，由终止而消亡。相应地，在操作系统中就有用于创建线程和终止线程的函数（或系统调用）。</p><p>用户程序启动时，通常仅有一个称为<strong>初始化线程</strong>的线程正在执行，其主要功能是用于创建新线程。在创建新线程时，需要利用一个线程创建函数，并提供相应的参数，如：指向线程主程序的入口指针；堆栈的大小；线程优先级等。</p><p>线程创建函数执行完后，将<strong>返回一个线程标识符</strong>。</p><p>3）线程的终止</p><p>当一个线程完成自己的任务后，或线程在运行中出现异常而要被强制终止时，由终止线程调用相应的函数执行终止操作。但是有些线程（主要是系统线程）一旦被建立，便一直运行而不会被终止。</p><p>通常，线程被终止后并不立即释放它所占有的资源，只有当进程中的其他线程执行了<strong>分离函数</strong>后，被终止线程才与资源分离，此时的资源才能被其他线程利用。</p><p>被终止但尚未释放资源的线程仍可被其他线程调用，以使被终止线程重新恢复运行。</p><h3>2.4 线程的实现方式</h3><p><img src="`+l+'" alt="线程实现方式"></p><h4>用户级线程ULT</h4><blockquote><p>所有操作都在用户态执行，无需操作系统干预，内核意识不到线程的存在</p></blockquote><p><strong>优点：</strong></p><blockquote><p>① 线程切换不需要转换到内核空间，节省了模式切换的开销。</p><p>② 调度算法可以是进程专用的，不同的进程可根据自身的需要，对自己的线程选择不同的调度算法。</p><p>③ 用户级线程的实现与操作系统平台无关，对线程管理的代码是属于用户程序的一部分。</p></blockquote><p><strong>缺点：</strong></p><blockquote><p>① 系统调用的阻塞问题，当线程执行一个系统调用时，不仅该线程被阻塞，而且进程内的所有线程都被阻塞。</p><p>② 不能发挥多CPU的优势，内核每次分配给一个进程的仅有一个CPU，因此进程中仅有一个线程能执行。</p></blockquote><h4>内核级线程KLT</h4><p>操作系统也为每个内核级线程设置一个线程控制块TCB，内核根据该控制块感知某线程的存在</p><p><strong>优点：</strong></p><blockquote><p>① 能发挥多CPU的优势，内核能同时调度同一进程中的多个线程并行执行。</p><p>② 如果进程中的一个线程被阻塞，内核可以调度该进程中的其他线程占用CPU，也可运行其他进程中的线程。</p><p>③ 内核支持线程具有很小的数据结构和堆栈，线程切换比较快、开销小。</p><p>④ 内核本身也可采用多线程技术，可以提高系统的执行速度和效率。</p></blockquote><p><strong>缺点</strong></p><blockquote><p>同一进程中的线程切换，需要从用户态转到核心态进行，系统开销较大。这是因为用户进程的线程在用户态运行，而线程调度和管理是在内核实现的。</p></blockquote><h4>组合方式</h4><h3>2.5 多线程模型</h3><p><img src="'+e+'" alt="线程-内核"></p><h2>2.3 CPU调度</h2><h3>3.1 调度分类</h3><p><img src="'+h+'" alt="CPU调度"></p><h3>3.2 调度实现</h3><p><strong>调度时机</strong></p><p><img src="'+c+'" alt="调度时机"></p><hr><p><img src="'+i+'" alt="临界区"></p><h2>2.4 同步与互斥</h2><h3>4.1 同步概念</h3><p><img src="'+a+'" alt="进程同步"></p><h3>4.2 互斥概念</h3><p><img src="'+d+'" alt="进程互斥"></p><p><img src="'+b+'" alt="互斥1"></p><p><img src="'+u+'" alt="互斥2"></p><h3>4.3 互斥的实现</h3><h4>互斥的软件实现</h4><p><img src="'+k+'" alt="单标志法"></p><blockquote><p>违背空间让进</p></blockquote><h4>互斥的硬件实现</h4><h2>2.5 死锁</h2><h1>第三章 内存管理</h1><h2>3.1 内存管理</h2><h3>内存管理的概念</h3><img src="'+m+'" alt="内存管理的概念" style="zoom:67%;"><h3>进程的内存映像</h3><img src="'+C+'" alt="进程的内存映像" style="zoom:67%;"><h3>覆盖技术</h3><img src="'+P+'" alt="覆盖技术" style="zoom:67%;"><h3>交换技术</h3><img src="'+q+'" alt="交换技术" style="zoom:67%;"><p><img src="'+B+'" alt="内存连续分配"></p><h3>基于顺序的搜索分配算法</h3><blockquote></blockquote><h3>基于索引搜索的分配算法</h3><blockquote><p>快速适应算法</p><p>伙伴系统</p><p>哈希算法</p></blockquote><h2>3.2 虚拟内存管理</h2><h1>第四章 文件管理</h1><h1>第五章 输入输出</h1>',168)])))}};export{x as category,I as date,E as default,A as summary,D as updated};
