import{o,c as p,a as c}from"./index-006907e8.js";const a="/blog/assets/树基本概念-5c5f0b03.png",l="/blog/assets/树的性质1-ae1cfddd.png",e="/blog/assets/树的性质2-7f4a00ec.png",g="/blog/assets/二叉树-451ceabd.png",r="/blog/assets/满二叉树-17e6de6c.png",n="/blog/assets/二叉排序树-b0daed0a.png",i="/blog/assets/平衡二叉树-78a09021.png",m="/blog/assets/中序线索化-237ae42a.png",b="/blog/assets/先序线索化-67298d14.png",_="/blog/assets/森林-53c5dee0.png",h="/blog/assets/带权路径-e47e8e07.png",u="/blog/assets/哈夫曼树1-519d8fb8.png",k="/blog/assets/哈夫曼编码-714175ac.png",d="/blog/assets/双亲表示法-73c3e161.png",q="/blog/assets/并查集-f11b763b.png",f="/blog/assets/Union优化-e266c204.png",F="/blog/assets/Find优化-0534a7cd.png",S="/blog/assets/并查集复杂度分析-047c1675.png",y="/blog/assets/图的基本概念-154285d5.png",D="/blog/assets/图的存储方式-76ce2fba.png",B="/blog/assets/邻接矩阵-fb58707c.png",T="/blog/assets/邻接矩阵性质-bda57886.png",Z="/blog/assets/邻接表-99cc3498.png",$="/blog/assets/邻接表和邻接矩阵-189200fa.png",j="/blog/assets/邻接多重表-89bccaec.png",w="/blog/assets/十字链表法-baff41bf.png",x="/blog/assets/BFS算法-fc747fcf.png",K="/blog/assets/BFS复杂度分析-65acfb41.png",U="/blog/assets/DFS算法-d761ed6c.png",P="/blog/assets/DFS时间复杂度-ee831a60.png",V="/blog/assets/DFS空间复杂度-7589c8da.png",v="/blog/assets/普里姆算法-7b3d631e.png",E="/blog/assets/Kruskal算法-66b29fec.png",N="/blog/assets/最小生成树-3d858776.png",O="/blog/assets/Dijkstra算法-a9ea36c5.png",z="/blog/assets/Floyd算法-4348bffd.png",A="/blog/assets/最短路径-5d3a2f0b.png",C={class:"markdown-body"},L="2025-10-07T00:00:00.000Z",M="2025-10-07T00:00:00.000Z",Q="考研复习",R="数据结构5树与二叉树6图",W={__name:"数据结构_2",setup(G,{expose:t}){return t({frontmatter:{date:"2025-10-07T00:00:00.000Z",updated:"2025-10-07T00:00:00.000Z",category:"考研复习",summary:"数据结构5树与二叉树6图"}}),(I,s)=>(o(),p("div",C,s[0]||(s[0]=[c('<h2>5.树</h2><p><img src="'+a+'" alt="树基本概念"></p><p><img src="'+l+'" alt="树的性质1"></p><p><img src="'+e+'" alt="树的性质2"></p><h3>二叉树</h3><h4>定义</h4><p><img src="'+g+'" alt="二叉树"></p><h4>满二叉树、完全二叉树</h4><p><img src="'+r+'" alt="满二叉树"></p><h4>二叉排序树</h4><p><img src="'+n+'" alt="二叉排序树"></p><h4>平衡二叉树</h4><p><img src="'+i+'" alt="平衡二叉树"></p><h4>正则二叉树</h4><blockquote><p>二叉树前序、中序、后序遍历</p></blockquote><h4>线索二叉树</h4><blockquote><p>中序线索化</p></blockquote><p><img src="'+m+'" alt="中序线索化"></p><blockquote><p>先序线索化</p></blockquote><p><img src="'+b+'" alt="先序线索化"></p><h3>树、森林</h3><p><img src="'+_+'" alt="森林"></p><h3>树的应用</h3><h4>哈夫曼树</h4><p><img src="'+h+'" alt="带权路径"></p><blockquote><p>加权平均长度 = $\\frac{\\displaystyle\\sum_{i=1}^n w_i * l_i}{\\displaystyle\\sum_{i=1}^n w_i}$</p></blockquote><p><img src="'+u+'" alt="哈夫曼树1"></p><blockquote><p>哈夫曼编码集和定长编码集</p></blockquote><p><img src="'+k+'" alt="哈夫曼编码"></p><h4>并查集</h4><p><img src="'+d+'" alt="双亲表示法"></p><blockquote><p>基本并查集</p><p>优化的思路都是尽可能让树变矮</p></blockquote><p><img src="'+q+'" alt="并查集"></p><blockquote><p>Union优化</p></blockquote><p><img src="'+f+'" alt="Union优化"></p><blockquote><p>Find 优化 路径压缩</p><p>第一次循环找到根节点、第二次循环将查找路径下的节点直接挂在在根结点下</p></blockquote><p><img src="'+F+'" alt="Find优化"></p><p><img src="'+S+'" alt="并查集复杂度分析"></p><h2>6.图</h2><h3>基本概念</h3><p><img src="'+y+'" alt="图的基本概念"></p><h3>图的存储</h3><p><img src="'+D+'" alt="图的存储方式"></p><h4>邻接矩阵</h4><p><img src="'+B+'" alt="邻接矩阵"></p><blockquote><p>有权图更改表中数值即可</p></blockquote><p><img src="'+T+'" alt="邻接矩阵性质"></p><h4>邻接表</h4><p><img src="'+Z+'" alt="邻接表"></p><p><img src="'+$+'" alt="邻接表和邻接矩阵"></p><h4>邻接多重表</h4><p><img src="'+j+'" alt="邻接多重表"></p><h4>十字链表</h4><p><img src="'+w+'" alt="十字链表法"></p><h3>图的遍历</h3><h4>BFS</h4><p><img src="'+x+'" alt="BFS算法"></p><p><img src="'+K+'" alt="BFS复杂度分析"></p><blockquote><p>广度优先生成树、广度优先生成森林</p></blockquote><h4>DFS</h4><p><img src="'+U+'" alt="DFS算法"></p><blockquote><p>复杂度分析</p></blockquote><p><img src="'+P+'" alt="DFS时间复杂度"></p><p><img src="'+V+'" alt="DFS空间复杂度"></p><blockquote><p>深度优先生成树</p></blockquote><h3>最小生成树</h3><h4>Prim普里姆算法</h4><blockquote><p>图示</p></blockquote><p><img src="'+v+'" alt="普里姆算法"></p><h4>Kruskal算法</h4><p><img src="'+E+'" alt="Kruskal算法"></p><blockquote><p>时间度、复杂度分析</p></blockquote><p><img src="'+N+'" alt="最小生成树"></p><h3>最短路径</h3><blockquote><p>单源最短路径、每对顶点最短路径</p></blockquote><h4>Dijkstra算法</h4><p><img src="'+O+'" alt="Dijkstra算法"></p><blockquote><p>时间复杂度 $O(|V|^2)$</p><p>类似Prim算法，每次找最短的那个节点，从这个结点出发，更新这一轮的最小距离</p><p>BFS 也能使用，但是要求权值都相同</p></blockquote><h4>Floyd算法</h4><p><img src="'+z+'" alt="Floyd算法"></p><p><img src="'+A+'" alt="最短路径"></p><blockquote><p>BFS的时间复杂度：邻接表、邻接矩阵</p></blockquote><h3>拓扑排序</h3>',83)])))}};export{Q as category,L as date,W as default,R as summary,M as updated};
