import{o as p,c as o,a as c}from"./index-e36c1b9e.js";const g="/blog/assets/顺序查找基本-10471856.png",a="/blog/assets/顺序查找哨兵-1be61080.png",l="/blog/assets/顺序查找效率分析-4f1bfb09.png",e="/blog/assets/顺序查找优化-4f8e5cff.png",r="/blog/assets/折半查找实现-202ab81f.png",n="/blog/assets/折半查找效率分析-f02673ee.png",m="/blog/assets/分块查找-9e9fc9f3.png",_="/blog/assets/分块动态数组-bd41ca0c.png",i="/blog/assets/二叉排序树查找-68eb7edb.png",b="/blog/assets/二叉排序树查找效率1-0b8c7c74.png",h="/blog/assets/二叉排序树查找效率2-5433ff69.png",d="/blog/assets/二叉排序树的插入-97c85e51.png",f="/blog/assets/二叉排序树删除1-7377b44e.png",u="/blog/assets/二叉排序树删除2-714b96a0.png",L="/blog/assets/二叉排序树删除3-5d12249c.png",k="/blog/assets/平衡二叉树定义-628af033.png",B="/blog/assets/LLRR左右旋代码-697c9d05.png",q="/blog/assets/调整平衡二叉树LL-077b3824.png",R="/blog/assets/调整平衡二叉树RR-852de999.png",A="/blog/assets/调整平衡二叉树LR-b0a8bcd0.png",V="/blog/assets/调整平衡二叉树RL-909c62d5.png",$="/blog/assets/AVL删除1-6e0cea00.png",x="/blog/assets/AVL删除2-1f59f0b1.png",y="/blog/assets/AVL删除3-8d771410.png",T="/blog/assets/AVL删除4-b726f86c.png",S="/blog/assets/红黑树定义1-a13b47ec.png",Z="/blog/assets/红黑树定义2-240e5449.png",w="/blog/assets/红黑树插入0-91600571.png",v="/blog/assets/红黑树插入1-7365ebc8.png",E="/blog/assets/红黑树插入2-fef1e139.png",N="/blog/assets/红黑树插入3-8cda9e5a.png",O="/blog/assets/红黑树插入4-4081150d.png",j="/blog/assets/红黑树插入5-7e746fe6.png",z="/blog/assets/红黑树插入6-8a42d783.png",C="/blog/assets/红黑树插入7-c0cc2b8f.png",D="/blog/assets/B树-c260e8df.png",F="/blog/assets/B树的定义-a8d2bd9d.png",G="/blog/assets/B树的插入-daa2b479.png",H="/blog/assets/B树的删除0-322c543d.png",I="/blog/assets/B树的删除1-91d552b8.png",J="/blog/assets/B树的删除2-1a2a02ce.png",K="/blog/assets/B树的删除3-4d6faa03.png",M="/blog/assets/B树的删除4-bf13056d.png",P="/blog/assets/B_树定义-5bb8e5d1.png",Q="/blog/assets/B_树-6eb6249e.png",U="/blog/assets/散列表概念-8ee72b9f.png",W="/blog/assets/散列函数要求-2b3ca4c3.png",X="/blog/assets/直接定址法-1d540df7.png",Y="/blog/assets/除留余数法-91db3804.png",ss="/blog/assets/数字分析法-a9a2f2a0.png",ts="/blog/assets/平方取中法-1bf1a3ea.png",ps="/blog/assets/开放定址法-4a9dc97b.png",os="/blog/assets/开放定址法删除1-11bcb0c6.png",cs="/blog/assets/拉链法解决冲突-0b5c6c99.png",gs="/blog/assets/散列表查找性能分析1-209df060.png",as="/blog/assets/堆积现象-6a8f3499.png",ls="/blog/assets/平方探测法缓解堆积现象-031e9330.png",es={class:"markdown-body"},is="2025-10-07T00:00:00.000Z",bs="2025-10-07T00:00:00.000Z",hs="考研复习",ds="数据结构7查找",fs={__name:"数据结构_3",setup(rs,{expose:t}){return t({frontmatter:{date:"2025-10-07T00:00:00.000Z",updated:"2025-10-07T00:00:00.000Z",category:"考研复习",summary:"数据结构7查找"}}),(ms,s)=>(p(),o("div",es,s[0]||(s[0]=[c('<h2>顺序查找</h2><h3>基本实现</h3><p><img src="'+g+'" alt="顺序查找基本"></p><p><img src="'+a+'" alt="顺序查找哨兵"></p><h3>ASL分析</h3><p><img src="'+l+'" alt="顺序查找效率分析"></p><p><img src="'+e+'" alt="顺序查找优化"></p><h2>折半查找</h2><h3>基本实现</h3><blockquote><p>基本只适合有序数组</p></blockquote><p><img src="'+r+'" alt="折半查找实现"></p><h3>ASL分析</h3><p><img src="'+n+'" alt="折半查找效率分析"></p><blockquote><p>失败节点数量 $n + 1$</p><p>$h = \\left\\lceil \\log_{2} (n + 1) \\right\\rceil$</p><p>折半查找不一定比顺序查找更优</p><p>任意的一个子树的左子树的节点数小于等于右子树数量或者反过来取决于mid = (low + high) / 2 是向上还是向下取整</p></blockquote><h3>分块查找</h3><p><img src="'+m+'" alt="分块查找"></p><blockquote><p>链式</p></blockquote><p><img src="'+_+'" alt="分块动态数组"></p><h2>树形查找</h2><h3>二叉排序树</h3><h4>查找</h4><p><img src="'+i+'" alt="二叉排序树查找"></p><blockquote><p>查找成功</p></blockquote><p><img src="'+b+'" alt="二叉排序树查找效率1"></p><blockquote><p>查找失败</p></blockquote><p><img src="'+h+'" alt="二叉排序树查找效率2"></p><h4>插入</h4><p><img src="'+d+'" alt="二叉排序树的插入"></p><h4>删除</h4><p><img src="'+f+'" alt="二叉排序树删除1"></p><p><img src="'+u+'" alt="二叉排序树删除2"></p><p><img src="'+L+'" alt="二叉排序树删除3"></p><h3>平衡二叉树</h3><blockquote><p>AVL树：对二叉排序树的优化</p></blockquote><h4>定义</h4><p><img src="'+k+'" alt="平衡二叉树定义"></p><blockquote><p>插入</p><p>！！！！！！！ LR和RL的旋转容易出错</p></blockquote><p><img src="'+B+'" alt="LLRR左右旋代码"></p><h4>LL</h4><p><img src="'+q+'" alt="调整平衡二叉树LL"></p><h4>RR</h4><p><img src="'+R+'" alt="调整平衡二叉树RR"></p><h4>LR</h4><p><img src="'+A+'" alt="调整平衡二叉树LR"></p><h4>RL</h4><p><img src="'+V+'" alt="调整平衡二叉树RL"></p><h4>删除</h4><blockquote><p>时间复杂度 ： $O(log_2 (n))$</p><p>删除节点需要找到前驱或者后继进行替换，这样删除的节点就会往下降，然后恢复平衡就可以了</p></blockquote><p><img src="'+$+'" alt="AVL删除1"></p><p><img src="'+x+'" alt="AVL删除2"></p><p><img src="'+y+'" alt="AVL删除3"></p><p><img src="'+T+'" alt="AVL删除4"></p><h3>红黑树</h3><blockquote><p>RBT</p><p>平衡二叉树的插入删除容易频繁调整树的形态，为解决这一问题引入了红黑树</p></blockquote><h4>定义</h4><blockquote><p>从根节点到叶节点最长路径不大于最短路径的两倍</p></blockquote><p><img src="'+S+'" alt="红黑树定义1"></p><p><img src="'+Z+'" alt="红黑树定义2"></p><h4>插入</h4><p><img src="'+w+'" alt="红黑树插入0"></p><p><img src="'+v+'" alt="红黑树插入1"></p><p><img src="'+E+'" alt="红黑树插入2"></p><p><img src="'+N+'" alt="红黑树插入3"></p><p><img src="'+O+'" alt="红黑树插入4"></p><p><img src="'+j+'" alt="红黑树插入5"></p><p><img src="'+z+'" alt="红黑树插入6"></p><p><img src="'+C+'" alt="红黑树插入7"></p><h2>B树</h2><p><img src="'+D+'" alt="B树"></p><h3>定义</h3><p><img src="'+F+'" alt=" "></p><h3>插入</h3><p><img src="'+G+'" alt="B树的插入"></p><h3>删除</h3><p><img src="'+H+'" alt="B树的删除0"></p><p><img src="'+I+'" alt="B树的删除1"></p><p><img src="'+J+'" alt="B树的删除2"></p><p><img src="'+K+'" alt="B树的删除3"></p><p><img src="'+M+'" alt="B树的删除4"></p><hr><h2>B+树</h2><h3>定义</h3><p><img src="'+P+'" alt="B+树定义"></p><h3>与B树异同</h3><p><img src="'+Q+'" alt="B+树"></p><h2>散列表</h2><h3>概念</h3><p><img src="'+U+'" alt="散列表概念"></p><h3>函数</h3><p><img src="'+W+'" alt="散列函数要求"></p><h4>直接定址法</h4><p><img src="'+X+'" alt="直接定址法"></p><h4>除留余数法</h4><p><img src="'+Y+'" alt="除留余数法"></p><h4>数字分析法</h4><p><img src="'+ss+'" alt="数字分析法"></p><h4>平方取中法</h4><p><img src="'+ts+'" alt="平方取中法"></p><h3>处理冲突</h3><h4>开放地址法</h4><p><img src="'+ps+'" alt="开放定址法"></p><p><img src="'+os+'" alt="开放定址法删除1"></p><blockquote><p>插入时遇到逻辑删除的位置，可以将数据加入这个位置中</p></blockquote><h4>拉链法</h4><p><img src="'+cs+'" alt="拉链法解决冲突"></p><h3>散列查找的性能分析</h3><blockquote><p>ASL</p><p>散列表的装填因子 $\\alpha = \\frac{\\text{表中记录数 n }}{\\text{散列表长度 m }}$</p><p>平均查找长度依赖于散列表的装填因子 $\\alpha$</p></blockquote><p><img src="'+gs+'" alt="散列表查找性能分析1"></p><p><img src="'+as+'" alt="堆积现象"></p><p><img src="'+ls+'" alt="平方探测法缓解堆积现象"></p>',110)])))}};export{hs as category,is as date,fs as default,ds as summary,bs as updated};
