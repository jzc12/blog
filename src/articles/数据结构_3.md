---
date: 2025-10-07
updated: 2025-10-07
category: 考研复习
summary: 数据结构7查找
---
## 顺序查找

### 基本实现

![顺序查找基本](./../../public/assets/数据结构/顺序查找基本.png)

![顺序查找哨兵](./../../public/assets/数据结构/顺序查找哨兵.png)

### ASL分析

![顺序查找效率分析](./../../public/assets/数据结构/顺序查找效率分析.png)

![顺序查找优化](./../../public/assets/数据结构/顺序查找优化.png)



## 折半查找

### 基本实现

> 基本只适合有序数组

![折半查找实现](./../../public/assets/数据结构/折半查找实现.png)

### ASL分析

![折半查找效率分析](./../../public/assets/数据结构/折半查找效率分析.png)

> 失败节点数量 $n + 1$
>
> $h = \left\lceil \log_{2} (n + 1) \right\rceil$ 
>
> 折半查找不一定比顺序查找更优
>
> 任意的一个子树的左子树的节点数小于等于右子树数量或者反过来取决于mid = (low + high) / 2 是向上还是向下取整



### 分块查找

![分块查找](./../../public/assets/数据结构/分块查找.png)

> 链式

![分块动态数组](./../../public/assets/数据结构/分块动态数组.png)



## 树形查找

### 二叉排序树

#### 查找

![二叉排序树查找](./../../public/assets/数据结构/二叉排序树查找.png)

> 查找成功

![二叉排序树查找效率1](./../../public/assets/数据结构/二叉排序树查找效率1.png)

> 查找失败

![二叉排序树查找效率2](./../../public/assets/数据结构/二叉排序树查找效率2.png)





#### 插入

![二叉排序树的插入](./../../public/assets/数据结构/二叉排序树的插入.png)

#### 删除

![二叉排序树删除1](./../../public/assets/数据结构/二叉排序树删除1.png)

![二叉排序树删除2](./../../public/assets/数据结构/二叉排序树删除2.png)

![二叉排序树删除3](./../../public/assets/数据结构/二叉排序树删除3.png)

### 平衡二叉树

> AVL树：对二叉排序树的优化

#### 定义

![平衡二叉树定义](./../../public/assets/数据结构/平衡二叉树定义.png)

> 插入
>
> ！！！！！！！ LR和RL的旋转容易出错

![LLRR左右旋代码](./../../public/assets/数据结构/LLRR左右旋代码.png)

#### LL

![调整平衡二叉树LL](./../../public/assets/数据结构/调整平衡二叉树LL.png)

#### RR

![调整平衡二叉树RR](./../../public/assets/数据结构/调整平衡二叉树RR.png)

#### LR

![调整平衡二叉树LR](./../../public/assets/数据结构/调整平衡二叉树LR.png)

#### RL

![调整平衡二叉树RL](./../../public/assets/数据结构/调整平衡二叉树RL.png)

#### 删除

> 时间复杂度 ： $O(log_2 (n))$
>
> 删除节点需要找到前驱或者后继进行替换，这样删除的节点就会往下降，然后恢复平衡就可以了

![AVL删除1](./../../public/assets/数据结构/AVL删除1.png)

![AVL删除2](./../../public/assets/数据结构/AVL删除2.png)



![AVL删除3](./../../public/assets/数据结构/AVL删除3.png)

![AVL删除4](./../../public/assets/数据结构/AVL删除4.png)





### 红黑树

> RBT
>
> 平衡二叉树的插入删除容易频繁调整树的形态，为解决这一问题引入了红黑树

#### 定义

> 从根节点到叶节点最长路径不大于最短路径的两倍
>
> 

![红黑树定义1](./../../public/assets/数据结构/红黑树定义1.png)

![红黑树定义2](./../../public/assets/数据结构/红黑树定义2.png)

#### 插入

![红黑树插入0](./../../public/assets/数据结构/红黑树插入0.png)

![红黑树插入1](./../../public/assets/数据结构/红黑树插入1.png)

![红黑树插入2](./../../public/assets/数据结构/红黑树插入2.png)

![红黑树插入3](./../../public/assets/数据结构/红黑树插入3.png)

![红黑树插入4](./../../public/assets/数据结构/红黑树插入4.png)

![红黑树插入5](./../../public/assets/数据结构/红黑树插入5.png)

![红黑树插入6](./../../public/assets/数据结构/红黑树插入6.png)

![红黑树插入7](./../../public/assets/数据结构/红黑树插入7.png)





## B树

![B树](./../../public/assets/数据结构/B树.png)

### 定义

![ ](./../../public/assets/数据结构/B树的定义.png)



### 插入

![B树的插入](./../../public/assets/数据结构/B树的插入.png)

### 删除

![B树的删除0](./../../public/assets/数据结构/B树的删除0.png)

![B树的删除1](./../../public/assets/数据结构/B树的删除1.png)

![B树的删除2](./../../public/assets/数据结构/B树的删除2.png)

![B树的删除3](./../../public/assets/数据结构/B树的删除3.png)

![B树的删除4](./../../public/assets/数据结构/B树的删除4.png)

---

## B+树



### 定义

![B+树定义](./../../public/assets/数据结构/B+树定义.png)

### 与B树异同

![B+树](./../../public/assets/数据结构/B+树.png)





## 散列表

### 概念

![散列表概念](./../../public/assets/数据结构/散列表概念.png)

### 函数

![散列函数要求](./../../public/assets/数据结构/散列函数要求.png)

#### 直接定址法

![直接定址法](./../../public/assets/数据结构/直接定址法.png)

#### 除留余数法

![除留余数法](./../../public/assets/数据结构/除留余数法.png)



#### 数字分析法

![数字分析法](./../../public/assets/数据结构/数字分析法.png)



#### 平方取中法

![平方取中法](./../../public/assets/数据结构/平方取中法.png)



### 处理冲突

#### 开放地址法

![开放定址法](./../../public/assets/数据结构/开放定址法.png)

![开放定址法删除1](./../../public/assets/数据结构/开放定址法删除1.png)

> 插入时遇到逻辑删除的位置，可以将数据加入这个位置中

#### 拉链法

![拉链法解决冲突](./../../public/assets/数据结构/拉链法解决冲突.png)



### 散列查找的性能分析

> ASL
>
> 散列表的装填因子 $\alpha = \frac{\text{表中记录数 n }}{\text{散列表长度  m }}$ 
>
> 平均查找长度依赖于散列表的装填因子 $\alpha$



![散列表查找性能分析1](./../../public/assets/数据结构/散列表查找性能分析1.png)



![堆积现象](./../../public/assets/数据结构/堆积现象.png)





![平方探测法缓解堆积现象](./../../public/assets/数据结构/平方探测法缓解堆积现象.png)













