---
date: 2025-10-07
updated: 2025-10-07
category: 考研复习
summary: 数据结构5树与二叉树6图
---
## 5.树

![树基本概念](./../../public/assets/数据结构/树基本概念.png)

![树的性质1](./../../public/assets/数据结构/树的性质1.png)

![树的性质2](./../../public/assets/数据结构/树的性质2.png)



### 二叉树

#### 定义

![二叉树](./../../public/assets/数据结构/二叉树.png)

#### 满二叉树、完全二叉树

![满二叉树](./../../public/assets/数据结构/满二叉树.png)

#### 二叉排序树

![二叉排序树](./../../public/assets/数据结构/二叉排序树.png)

#### 平衡二叉树

![平衡二叉树](./../../public/assets/数据结构/平衡二叉树.png)

#### 正则二叉树

> 二叉树前序、中序、后序遍历

#### 线索二叉树

> 中序线索化

![中序线索化](./../../public/assets/数据结构/中序线索化.png)

> 先序线索化

![先序线索化](./../../public/assets/数据结构/先序线索化.png)

### 树、森林

![森林](./../../public/assets/数据结构/森林.png)

### 树的应用

#### 哈夫曼树

![带权路径](./../../public/assets/数据结构/带权路径.png)

> 加权平均长度 = $\frac{\displaystyle\sum_{i=1}^n w_i * l_i}{\displaystyle\sum_{i=1}^n w_i}$



![哈夫曼树1](./../../public/assets/数据结构/哈夫曼树1.png)

> 哈夫曼编码集和定长编码集



![哈夫曼编码](./../../public/assets/数据结构/哈夫曼编码.png)

#### 并查集

![双亲表示法](./../../public/assets/数据结构/双亲表示法.png)

> 基本并查集
>
> 优化的思路都是尽可能让树变矮

![并查集](./../../public/assets/数据结构/并查集.png)

> Union优化

![Union优化](./../../public/assets/数据结构/Union优化.png)

> Find 优化 路径压缩
>
> 第一次循环找到根节点、第二次循环将查找路径下的节点直接挂在在根结点下

![Find优化](./../../public/assets/数据结构/Find优化.png)

![并查集复杂度分析](./../../public/assets/数据结构/并查集复杂度分析.png)



## 6.图

### 基本概念

![图的基本概念](./../../public/assets/数据结构/图的基本概念.png)

### 图的存储

![图的存储方式](./../../public/assets/数据结构/图的存储方式.png)

#### 邻接矩阵

![邻接矩阵](./../../public/assets/数据结构/邻接矩阵.png)

> 有权图更改表中数值即可

![邻接矩阵性质](./../../public/assets/数据结构/邻接矩阵性质.png)

#### 邻接表

![邻接表](./../../public/assets/数据结构/邻接表.png)



![邻接表和邻接矩阵](./../../public/assets/数据结构/邻接表和邻接矩阵.png)

#### 邻接多重表

![邻接多重表](./../../public/assets/数据结构/邻接多重表.png)

#### 十字链表

![十字链表法](./../../public/assets/数据结构/十字链表法.png)



### 图的遍历

#### BFS

![BFS算法](./../../public/assets/数据结构/BFS算法.png)

![BFS复杂度分析](./../../public/assets/数据结构/BFS复杂度分析.png)

> 广度优先生成树、广度优先生成森林

#### DFS

![DFS算法](./../../public/assets/数据结构/DFS算法.png)

> 复杂度分析

![DFS时间复杂度](./../../public/assets/数据结构/DFS时间复杂度.png)

![DFS空间复杂度](./../../public/assets/数据结构/DFS空间复杂度.png)

> 深度优先生成树



### 最小生成树

#### Prim普里姆算法

> 图示

![普里姆算法](./../../public/assets/数据结构/普里姆算法.png)



#### Kruskal算法

![Kruskal算法](./../../public/assets/数据结构/Kruskal算法.png)

> 时间度、复杂度分析

![最小生成树](./../../public/assets/数据结构/最小生成树.png)

### 最短路径

> 单源最短路径、每对顶点最短路径

#### Dijkstra算法

![Dijkstra算法](./../../public/assets/数据结构/Dijkstra算法.png)

> 时间复杂度 $O(|V|^2)$
>
> 类似Prim算法，每次找最短的那个节点，从这个结点出发，更新这一轮的最小距离
>
> BFS 也能使用，但是要求权值都相同

#### Floyd算法

![Floyd算法](./../../public/assets/数据结构/Floyd算法.png)

![最短路径](./../../public/assets/数据结构/最短路径.png)

> BFS的时间复杂度：邻接表、邻接矩阵



### 拓扑排序





