---
date: 2025-10-07
updated: 2025-10-07
category: 考研复习
summary: 数据结构8排序
---

## 基本概念

![排序基本概念](./../../public/assets/数据结构/排序基本概念.png)

![内部排序](./../../public/assets/数据结构/内部排序.png)



## 插入排序

![插入排序](./../../public/assets/数据结构/插入排序.png)

### 直接插入排序

```c++
// 不带哨兵形式
void insertionSort(int arr[], int n) {
    for (int i = 1; i < n; i++) {
        int key = arr[i];
        int j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}
```





![直接插入排序](./../../public/assets/数据结构/直接插入排序.png)





### 折半插入排序

![折半插入排序](./../../public/assets/数据结构/折半插入排序.png)

### 希尔排序

![希尔排序图示](./../../public/assets/数据结构/希尔排序图示.png)



```c++
void shellSort(int arr[], int n) {
    for (int d = n / 2; d > 0; d = d / 2) {  // 增量序列
        for (int i = d; i < n; i++) {        // 从第d个元素开始
            int temp = arr[i];               // 待插入元素
            int j;
            // 对子序列进行插入排序
            for (j = i; j >= d && arr[j - d] > temp; j -= d) {
                arr[j] = arr[j - d];         // 元素后移
            }
            arr[j] = temp;                   // 插入正确位置
        }
    }
}
```







## 交换排序

### 冒泡排序

![冒泡排序](./../../public/assets/数据结构/冒泡排序.png)

> 稳定
>
> 空间复杂度 $O(1)$
>
> 时间复杂度最好：$O(1)$、最坏：$O(n^2)$ 
>
> 适用于链表

### 快速排序

![快速排序](./../../public/assets/数据结构/快速排序.png)

![快速排序复杂度](./../../public/assets/数据结构/快速排序复杂度.png)

> 快排并不稳定，例如：2、2、1
>
> 2014年的考题、和2019年考题对一趟的定义：对尚未确定最终位置的所有元素进行一遍处理称为一趟
>
> 这样快排就满足，比如第二趟至少有两个元素确定了位置
>
> 1.两个元素至少有一个位于最左或者最右
>
> 2.若没有元素位于最左或者最右，那么至少有三个元素确定位置，因为第一趟确定一个，第二趟进行了左右的两边操作



## 选择排序

### 简单选择排序

![简单选择排序](./../../public/assets/数据结构/简单选择排序.png)

![简单选择排序分析](./../../public/assets/数据结构/简单选择排序分析.png)

### 堆排序

![堆排序](./../../public/assets/数据结构/堆排序.png)

> 不稳定
>
> 插入到最后一个位置
>
> 删除，与这个节点的最后一个子节点交换，然后上下移动







## 归并排序

![归并排序](./../../public/assets/数据结构/归并排序.png)

![归并排序代码](./../../public/assets/数据结构/归并排序代码.png)



## 基数排序

![基数排序](./../../public/assets/数据结构/基数排序.png)

![基数排序图示](./../../public/assets/数据结构/基数排序图示.png)



## 外部排序

![外部排序](./../../public/assets/数据结构/外部排序.png)

### 外部排序原理

![外部排序原理](./../../public/assets/数据结构/外部排序原理.png)

![外部排序时间开销](./../../public/assets/数据结构/外部排序时间开销.png)

![外部排序优化1](./../../public/assets/数据结构/外部排序优化1.png)

![外部排序优化2](./../../public/assets/数据结构/外部排序优化2.png)

![外部排序优化3](./../../public/assets/数据结构/外部排序优化3.png)

### 败者树

![败者树背景](./../../public/assets/数据结构/败者树背景.png)

![败者树应用](./../../public/assets/数据结构/败者树应用.png)

![败者树](./../../public/assets/数据结构/败者树.png)



### 置换选择排序

> 目的是减少归并段的数量
>
> 对于 n 个数据， m 大小的缓冲区，
>
> 第一个归并段最大的长度是 n, 数据升序
>
> 第一个归并段最小的长度是m, 数据降序

![置换选择排序](./../../public/assets/数据结构/置换选择排序.png)

![置换选择排序图示](./../../public/assets/数据结构/置换选择排序图示.png)



### 最佳归并树

![最佳归并树图示](./../../public/assets/数据结构/最佳归并树图示.png)

> 哈夫曼树实现

![多叉最佳归并树](./../../public/assets/数据结构/多叉最佳归并树.png)

![含虚段的最佳归并树](./../../public/assets/数据结构/含虚段的最佳归并树.png)

![最佳归并树虚段数量](./../../public/assets/数据结构/最佳归并树虚段数量.png)

