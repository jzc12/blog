---
date: 2025-07-01
updated: 2025-07-30
category: 考研复习
summary: 操作系统 
---

## 进程与线程

### 2.1 进程与线程

#### 2.1.1 进程的概念和特征

+   进程的概念

![](./../../public/assets/os/73bdd5f627934b8f946376724fd7d4fc.webp) ![](./../../public/assets/os/7100b4090b4b4789b9e5b54463d34442.webp)

+   进程的特征

![](./../../public/assets/os/6da124e47c294d48a992969fc927f968.webp)

#### 2.1.2 进程的组成

![](./../../public/assets/os/69d414501373468dbc4a225bafa71677.webp)

![](./../../public/assets/os/a46db6563ba1462f9a8023115e7bb79c.webp)

注 ：PCB是操作系统用的 ，而程序段和数据段都只是程序用的。

![](./../../public/assets/os/8c2c7ec825ab4a54a881f0499ff948ec.webp) ![](./../../public/assets/os/e8c2102128d147cca1839b18cb6b6f44.webp)

#### 2.1.3 进程的状态与转换

![](./../../public/assets/os/beb2542465a5427484455a21e4e75859.webp)

![](./../../public/assets/os/0ffe6b1b04c84ad49ad2864bc5e5c86a.webp) ![](./../../public/assets/os/6cf869e9211949a7aaa156f01bb539d2.webp) ![](./../../public/assets/os/5f28cbca3191421d8b22ad53e8bb0b52.webp)

+   进程的组织 （可能是一个被删掉的考点 ）

![](./../../public/assets/os/16a8fb2bd8d74a508068b199169fc2f0.webp) ![](./../../public/assets/os/9ff5748a76d543949ec9541d2c54a2e1.webp) ![](./../../public/assets/os/85c6ae2e9334469b95563f7f5bf48942.webp)

#### 2.1.4 进程控制

![](./../../public/assets/os/04f550140293441da8fac90d9832a8ff.webp)

+   进程的创建  
    
    ![](./../../public/assets/os/1e31d0ec152b463284f87853e5714ead.webp)
+   进程的终止  
    
    ![](./../../public/assets/os/f3df176c717945cabc26a3d4b6008e0b.webp)
+   进程的阻塞和唤醒  
    
    ![](./../../public/assets/os/242a73a48ee1469eb66023c0b68afc16.webp)
+   进程的切换![](./../../public/assets/os/eef37159f54348f68762b0fb80255f24.webp)

#### 2.1.5 进程的通信

![](./../../public/assets/os/c2bd40d11f9a42f0842a1da1bc9bb3e1.webp)

1.  共享存储  
    
    ![](./../../public/assets/os/4dcc6ac3bee44b1c9acbb0cb2776d7d8.webp)
2.  消息传递![](./../../public/assets/os/2ca1b87902424eb58b021adf6abb9134.webp)
    1.  直接通信方式  
        
        ![](./../../public/assets/os/21e10ad486384e66af447da6ba96622e.webp)
    2.  间接通信方式  
        
        ![](./../../public/assets/os/5060cfbb6ca74be78afbaf9a2338c200.webp)
3.  管道通信  
    
    
    ![](./../../public/assets/os/1944d85ef4b94716bf2420905f6aad34.webp)

注 ：一个管道允许多个写进程 ，一个读进程。

#### 2.1.6 线程和多线程模型

![](./../../public/assets/os/2ec906b63cf147af82ad6cbb865d9119.webp)

1、线程的基本概念

![](./../../public/assets/os/299b84a72a654fa0a8427faccc8f7e8b.webp)

2、线程与进程的比较

![](./../../public/assets/os/2eeb2894cb51408ea4f7e50d758982e0.webp) ![](./../../public/assets/os/eee1476ab70845a2b0e484777ca6ef87.webp)

3、线程的属性

![](./../../public/assets/os/06d2aa2ce2ee4b7487ace35b70dc0d49.webp)

4、线程的状态和转换

![](./../../public/assets/os/6ffc07707993479592f2a573d5677f6b.webp)

注 ：就和进程一样一样滴。

5、线程的组织和控制

1.  线程控制块 ：与进程类似 ，系统也为每个线程配置一个线程控制块TCB ，用于记录控制和管理线程的信息。同一进程中的所有线程都完全共享进程的地址空间和全局变量。各个线程都可以访问进程地址空间的每个单元 ，所以一个线程可以读、写或甚至清除另一个线程的堆栈。线程控制块通常包括 ：
    1.  线程标识符 ；
    2.  一组寄存器 ，包括程序计数器、状态寄存器和通用寄存器 ；
    3.  线程运行状态 ，用于描述线程正处于何种状态 ；
    4.  优先级 ；
    5.  线程专有存储区 ，线程切换时用于保存现场等 ；
    6.  堆栈指针 ，用于过程调用时保存局部变量及返回地址等。
2.  线程的创建 ：线程也是具有生命期的 ，它由创建而产生 ，由调度而执行 ，由终止而消亡。相应地 ，在操作系统中就有用于创建线程和终止线程的函数 （或系统调用 ）。用户程序启动时 ，通常仅有一个称为初始化线程的线程正在执行 ，其主要功能是用于创建新线程。在创建新线程时 ，需要利用一个线程创建函数 ，并提供相应的参数 ，如指向线程主程序的入口指针、堆栈的大小、线程优先级等。线程创建函数执行完后 ，将返回一个线程标识符。
3.  线程的终止 ：当一个线程完成自己的任务后 ，或线程在运行中出现异常而要被强制终止时 ，由终止线程调用相应的函数执行终止操作。但是有些线程 （主要是系统线程 ）一旦被建立 ，便一直运行而不会被终止。通常 ，线程被终止后并不立即释放它所占有的资源 ，只有当进程中的其他线程执行了分离函数后 ，被终止线程才与资源分离 ，此时的资源才能被其他线程利用。终止但尚未释放资源的线程仍可被其他线程调用 ，以使被终止线程重新恢复运行。

6、线程的实现方式

![](./../../public/assets/os/7cd0d115e37840b48aa694dbfe1545ef.webp)

![](./../../public/assets/os/f3727d533e4845fb93851021fa829835.webp)

7、多线程模型

![](./../../public/assets/os/56b56c2969394d27bcc652de7d918f42.webp) ![](./../../public/assets/os/a9dbb9d4fb8445549e938090a4c08f3c.webp)

![](./../../public/assets/os/26f022ddbc534579a248d4b414d237bc.webp)

#### 2.1.7 本节小结

##### 1 为什么要引入进程 ？

> 在多道程序设计的背景下 ，进程之间需要共享系统资源 ，因此会导致各程序在执行过程中出现相互制约的关系 ，程序的执行会表现出间断性等特征。这些特征都是在程序的执行过程中发生的 ，是动态的过程 ，而传统的程序本身是一组指令的集合 ，是静态的概念 ，无法描述程序在内存中的执行情况 ，即无法从程序的字面上看出它何时执行、何时停顿 ，也无法看出它与其他执行程序的关系 ，因此 ，程序这个静态概念已不能如实反映程序并发执行过程的特征。为了深刻描述程序动态执行过程的性质乃至更好地支持和管理多道程序的并发执行 ，便引入了进程的概念。

##### 2 什么是进程 ？进程由什么组成 ？

> 进程是一个具有独立功能的程序关于某个数据集合的一次运行活动。它可以申请和拥有系统资源 ，是一个动态的概念 ，是一个活动的实体。它不只是程序的代码本身 ，还包括当前的活动通过程序计数器的值和处理寄存器的内容来表示。  
> 一个进程实体由程序段、相关数据段和PCB三部分构成 ，其中PCB是标志一个进程存在的唯一标识 ，程序段是进程运行的程序的代码 ，数据段则存储程序运行过程中相关的一些数据。

##### 3 进程是如何解决问题的 ？

> 进程将能够识别程序运行状态的一些变量存放在PCB中 ，通过这些变量系统能够更好地了解进程的状况 ，并在适当时机进行进程的切换 ，以避免一些资源的浪费 ，甚至划分为更小的调度单位一一线程来提高系统的并发度。

本节主要介绍什么是进程 ，并围绕这个问题进行一些闸述和讨论 ，为下一节讨论的内容做铺垫 ，但之前未学过相关课程的读者可能会比较费解 ，到现在为止对进程这个概念还未形成比较清晰的认识。接下来 ，我们再用一个比较熟悉的概念来类比进程 ，以便大家能彻底理解本节的内容到底在讲什么 ，到底解决了什么问题。  
我们用“人的生命历程”来类比进程。首先 ，人的生命历程一定是一个动态的、过程性的概念 ，要研究人的生命历程 ，先要介绍经历这个历程的主体是什么。主体当然是人 ，相当于经历进程的主体是进程映像 ，人有自己的身份 ，相当于进程映像里有PCB ；人生历程会经历好几种状态 ；出生的时候、弥留的时候、充满斗志的时候、发奋图强的时候及失落的时候 ，相当于进程有创建、撤销、就绪、运行、阻塞等状态 ，这几种状态会发生改变 ，人会充满斗志而转向发奋图强 ，发奋图强获得进步之后又会充满斗志预备下一次发奋图强 ，或者发奋图强后遇到阻碍会进入失落状态 ，然后在别人的开导之下又重新充满斗志。类比进程 ，会由就绪态转向运行态 ，运行态转向就绪态 ，或者运行态转向阻塞态 ，然后在别的进程帮助下返回就绪态。若我们用“人生历程”这个过程的概念去类比进程 ，则对进程的理解就更深一层。前面生活化的例子可以帮我们理解进程的实质 ，但它毕竞有不严谨的地方。一种较好的方式是 ，在类比进程和人生历程后 ，再看一遍前面较为严谨的书面述和讨论 ，这样对知识的掌握会更加准确而全面。  
这里再给出一些学习计算机科学知识的建议。学习时 ，很多同学会陷入一个误区 ，即只注重对定理、公式的应用 ，而忽视对基础概念的理解。这是我们从小到大应付考试而培养出的一个毛病 ，因为熟练应用公式和定理对考试有立见影的效果。公式、定理的应用固然重要 ，但基础概念的理解能让我们透彻地理解一门学科 ，更利于我们产生兴趣 ，培养创造性思维。

### 2.2 CPU调度

#### 2.2.1 调度的概念

![](./../../public/assets/os/50918da9cf7f42e18639f08ab0516b42.webp)

1、调度的基本概念

在多道程序系统中 ，进程的数量往往多于CPU的个数 ，因此进程争用CPU的情况在所难免。CPU调度是对CPU进行分配 ，即从就绪队列中按照一定的算法 （公平、高效的原则 ）选择一个进程并将CPU分配给它运行 ，以实现进程并发地执行。  
CPU调度是多道程序操作系统的基础 ，是操作系统设计的核心问题。

2、调度的层次

![](./../../public/assets/os/32612d79539140b7bc4d44bd7853f452.webp) ![](./../../public/assets/os/bd06f5614e7a4034b095750a718b8ac4.webp) ![](./../../public/assets/os/2284ff3a8c9f4b4596e697156af856fa.webp)

3、三级调度的联系

![](./../../public/assets/os/9208766fa34a43e2ba30b5dd1927b5a7.webp)

#### 2.2.2 调度的实现

1、调度程序 （调度器 ）

![](./../../public/assets/os/0e4e88995abc4938b66c79c5d30fc368.webp) ![](./../../public/assets/os/752c8187135e428c89af287856548389.webp)

2、调度的时机、切换和过程

![](./../../public/assets/os/f5814d2f5de04cdfab53be8d76f4bac1.webp) ![](./../../public/assets/os/7e73dc12c6614e1bb0cd39394868c1dd.webp)

![](./../../public/assets/os/c9785c879bcc44aebfcab11cfcf92f38.webp)

3、进程调度的方式

![](./../../public/assets/os/d46acb98489d42c7915657fc5300ff6d.webp)

4、闲逛进程

![](./../../public/assets/os/a17577df78be4f7396fed81ab8026750.webp)

5、两种线程的调度

#### 2.2.3 调度的目标

![](./../../public/assets/os/5f15a932ebf943db974e19713cdc898b.webp)

#### 2.2.4 进程切换

#### 2.2.5 典型的调度算法

![](./../../public/assets/os/c91d04480d55426cad6a7c9a46a95835.webp) ![](./../../public/assets/os/7586ff06fdce4e6c9c4d0b8c23929275.webp)

##### 1 先来先服务 （FCFS ）算法

![](./../../public/assets/os/ae4f89b76a2c4544b851b30daadcc9d6.webp) ![](./../../public/assets/os/51f0308d05274d9dae859d1b871b9027.webp)

##### 2 短作业优先 （SJF ）算法

![](./../../public/assets/os/770a7fb20f044171b174d8822c53e680.webp) ![](./../../public/assets/os/c4be742ae84741a099c5fdd896b3ca82.webp) ![](./../../public/assets/os/768d090cde6b46b49790a31f907ba79d.webp) ![](./../../public/assets/os/0b45475038044c0e88a3e1dad111a861.webp)

##### 3 高响应比优先调度算法

![](./../../public/assets/os/363a26543ad74f39afb785d6bd2ee7dd.webp) ![](./../../public/assets/os/5b2ebe95602f44e4bb21eca6297aab0c.webp)

##### 4 优先级调度算法

![](./../../public/assets/os/0d5eae04f8f04ed99aefbc8f1eb20dc9.webp)

![](./../../public/assets/os/3bcaf0847b624952b432cde3ab01cf77.webp) ![](./../../public/assets/os/89728cf9e7074367add63b0d1dd269c9.webp) ![](./../../public/assets/os/894edf7b196246218eb95aa9f66e6aa1.webp)

##### 5 时间片轮转 （RR ）调度算法

![](./../../public/assets/os/9cedcbef37f147efab1f2307375c39a4.webp) ![](./../../public/assets/os/c0da67e3487f4977b1aa1005b089ea61.webp) ![](./../../public/assets/os/cdf7f65e56394032b2f63f643424277e.webp)

##### 6 多级队列调度算法

![](./../../public/assets/os/0e07e17e6cb944ac91f7d920c7e8c5db.webp)

##### 7 多级反馈队列调度算法

![](./../../public/assets/os/03b30fdb0a9848c89933fd006121b1dd.webp) ![](./../../public/assets/os/e4f640d60d5a4410851d6432dd109ca5.webp)

#### 2.2.6 本节小结

##### 1 为什么要进行CPU调度 ？

> 若没有CPU调度 ，则意味着要等到当前运行的进程执行完毕后 ，下一个进程才能执行 ，而实际情况中 ，进程时常需要等待一些外部设备的输入 ，而外部设备的速度与CPU相比是非常缓慢的 ，若让CPU总是等待外部设备 ，则对CPU的资源是极大的浪费。而引进CPU调度后 ，可在运行进程等待外部设备时 ，将CPU调度给其他进程 ，从而提高CPU的利用率。用一句简单的话说 ，就是为了合理地处理计算机的软/硬件资源。

##### 2 调度算法有哪几种 ？

> 本节介绍的调度算法有先来先服务调度、短作业优先调度、优先级调度、高响应比优先调度、时间片轮转调度、多级队列调度、多级反馈队列调度 7种。 
> 先来先服务算法和短作业优先算法无法保证及时地接收和处理问题 ，因此无法保证在规定的时间间隔内响应每个用户的需求 ，也同样无法达到实时操作系统的及时性需求。优先级调度算法按照任务的优先级进行调度 ，对于更紧急的任务给予更高的优先级 ，适合实时操作系统。 
> 高响应比优先调度算法、时间片轮转调度算法、多级反馈队列调度算法都能保证每个任务在一定时间内分配到时间片 ，并轮流占用CPU ，适合分时操作系统。

本节主要介绍了CPU调度的概念。操作系统主要管理CPU、内存、文件、设备几种资源只要对资源的请求大于资源本身的数量 ，就会涉及调度。例如 ，在单处理器系统中 ，CPU只有一个 ，而请求的进程却有多个 ，因此就需要CPU调度。出现调度的概念后 ，又有了一个问题 ，即如何调度、应该满足谁、应该让谁等待 ，这是调度算法所面对的问题 ；而应该满足谁、应该让谁等待 ，要遵循一定的准则。调度这一概念贯穿于操作系统的始终 ，读者在接下来的学习中 ，将接触到几种资源的调度问题。将它们与CPU调度的内容相对比 ，将发现有异曲同工之妙。

### 2.3 同步与互斥

#### 2.3.1 同步与互斥的基本概念

![](./../../public/assets/os/19b1322aa4834ad699182ffd3d062d5c.webp)

+   临界资源和互斥

![](./../../public/assets/os/390faa882f7949218a954fdf63ded81a.webp) ![](./../../public/assets/os/1b552a7d9c9c44b2936a38cceadaefea.webp)

+   实现临界区互斥必须遵循的准则

![](./../../public/assets/os/fc96888b3fa549fc8147383d7dbc84e8.webp)

+   同步

![](./../../public/assets/os/daa82cf54aef4cd7a1a1f6135da5a104.webp)

#### 2.3.2 实现临界区互斥的基本方法

![](./../../public/assets/os/fca0f20d0e7b4b098a5d594dfac1e184.webp) ![](./../../public/assets/os/7e38f067880446649f014f5fba504ff7.webp)

1.  软件实现方法
    1.  单标志法  
        
        ![](./../../public/assets/os/5ceeb5373d74446c89fc5c06980f4652.webp)  
        注 ：违背了“空闲让进”准则 （两个进程必须交替进入临界区 ）
    2.  双标志先检查法  
        
        ![](./../../public/assets/os/e5613317df3d4fc4aa88cd7bd41e3e96.webp)
    3.  双标志后检查法  
        
        ![](./../../public/assets/os/a34c88d1ef6f4a1bb9b0916758f42d98.webp)  
        注 ：违背了“空闲让进 ”准则 ，且因此会导致“饥饿”现象 （违背了“有限等待”准则 ）
    4.  Peterson算法  
        
        ![](./../../public/assets/os/e2f0ed91e1d643dfa3e8e3fbc17a1371.webp)  
        注 ：很好的遵守了其他三个准则 ，但是还是违背了“让权等待”
2.  硬件实现方法
    1.  中断屏蔽方法  
        
        ![](./../../public/assets/os/3c842c22858c4f3d98a4ce250e29260d.webp)
    2.  硬件指令方法——TestAndSet方法  
        
        ![](./../../public/assets/os/0aebd1ba46b342aeaa14e88df52239b9.webp)  
        注 ：违背了“让权等待”
    3.  硬件指令方法——Swap方法  
        
        ![](./../../public/assets/os/e1ced705cce947038d39069388e9d185.webp)

#### 2.3.3 互斥锁

![](./../../public/assets/os/ccd4b1a5ddaa41fb86c4ee1bee037007.webp)

#### 2.3.4 信号量

![](./../../public/assets/os/0715bb4a913d42d99636677035aa1cb9.webp) ![](./../../public/assets/os/e40adfc685ca42d3a762adf655f01381.webp)

![](./../../public/assets/os/cc0be922c5a6488b955b1c5afaffd68b.webp)

+   整型信号量  
    
    ![](./../../public/assets/os/dbedc79b5e01407da4d4d0903ff36d9e.webp)
+   记录型信号量  
    
    ![](./../../public/assets/os/dd458c7dfc7640c6acee1b77b5f279a9.webp) ![](./../../public/assets/os/92c3502502d14dd8b8613353f19449bd.webp) ![](./../../public/assets/os/cd1767bc3f374ac6b551df429529f4b5.webp)
+   利用信号量实现进程互斥  
    
    ![](./../../public/assets/os/c762c61569be4a0c9b1607c890f2e4b8.webp)
+   利用信号量实现同步  
    
    ![](./../../public/assets/os/a4689d6840f34818aca143f2cf3c1922.webp)
+   利用信号量实现前驱关系 （多级同步 ）  
    
    ![](./../../public/assets/os/d592ad2759eb4d85b7629a8cb5e91cd0.webp)

#### 2.3.5 经典同步问题

##### 1 生产者-消费者问题

1.  单消费者单生产者  
    
    ![](./../../public/assets/os/beacbcf830cf418797da5f8d1ab2d274.webp) ![](./../../public/assets/os/6d45d4e1346c4b1b8e0ce0ebdd34ac78.webp) ![](./../../public/assets/os/fb27e032955d426d96b97fe5611f4e20.webp)  
    注 ：一定得是先同步后互斥 ，否则将造成死锁。  
    ![](./../../public/assets/os/4c92ec1fb004485e9d900e371b6d8b49.webp)
2.  多消费者多生产者  
    
    ![](./../../public/assets/os/151aad628ab04f74bfdb185afcf3cbab.webp)  
    注 ：该结论不适用于多个盘子也就是盘子容量不唯一的情况哦。

##### 2 读者-写者问题

![](./../../public/assets/os/5a5285e751b74854815e04d0241cf5ee.webp)

![](./../../public/assets/os/75a37051db5b43279837d43eccda56c9.webp) ![](./../../public/assets/os/40be8ad0cbf44b00b98a94e5bd1657f2.webp)

##### 3 哲学家进餐问题

![](./../../public/assets/os/5b2c1d7805d84ad69f1c02a2e19fbb82.webp)

##### 4 吸烟者问题

![](./../../public/assets/os/b1b49a47aa9a48c493b550b4e3ba0705.webp) ![](./../../public/assets/os/5af71f04121542c7bc27473ea3f6382b.webp) ![](./../../public/assets/os/f3cebb038f904082a836d37fd55d6eea.webp)

#### 2.3.6 管程

![](./../../public/assets/os/64aac2e36ef146aa825375bbfaf2adfb.webp)

![](./../../public/assets/os/78675fd72b0c4f3ba391a6be84a913bb.webp)

![](./../../public/assets/os/76595293865e406ba53e405c4ed00aab.webp) ![](./../../public/assets/os/a3bf3d36063a454584d12a9cea42048f.webp)

#### 2.3.7 本节小结

1 ）为什么要引入进程同步的概念 ？

在多道程序共同执行的条件下 ，进程与进程是并发执行的 ，不同进程之间存在不同的相互制约关系。为了协调进程之间的相互制约关系 ，引入了进程同步的概念。

2 ）不同的进程之间会存在什么关系 ？

进程之间存在同步与互的制约关系  
同步是指为完成某种任务而建立的两个或多个进程 ，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系  
互斥是指当一个进程进入临界区使用临界资源时 ，另一个进程必须等待 ，当占用临界资源的进程退出临界区后 ，另一进程才允许去访问此临界资源。

3 ）当单纯用本节介绍的方法解决这些问题时会遇到什么新的问题吗 ？

当两个或两个以上的进程在执行过程中 ，因占有一些资源而又需要对方的资源时 ，会因为争夺资源而造成一种互相等待的现象 ，若无外力作用 ，它们都将无法推进下去。这种现象称为死锁。

### 2.4 死锁

#### 2.4.1 死锁的概念

![](./../../public/assets/os/351725144ac240f4af100f5d79f85b6e.webp)

+   死锁、饥饿和死循环的共同点和区别

![](./../../public/assets/os/8b1b0aa045db4fccaea1beeaaf877894.webp)

+   死锁产生的必要条件

![](./../../public/assets/os/3794a379e02d4b3d84f9fa7a99fc2df3.webp)

+   什么时候会发生死锁

![](./../../public/assets/os/c4aa54f68d274ba1be1e4ec8ce620c4f.webp)

+   死锁的处理机制

![](./../../public/assets/os/d38e218d966842afa4f5fdb77dac9698.webp)

#### 2.4.2 死锁预防

![](./../../public/assets/os/904a4e7ea6074baa8588aa664ed72c83.webp)

1.  破环互斥条件  
    
    ![](./../../public/assets/os/e557ee37f3fe48d9a3bd3230b8d9fd34.webp)
2.  破坏不可剥夺条件  
    
    ![](./../../public/assets/os/3bb45b6241d34308bc207e956e641d0d.webp)
3.  破坏请求并保持条件  
    
    ![](./../../public/assets/os/c204de87249b45c3b6ea0a5b02f6c9d4.webp)
4.  破环循环等待条件  
    
    ![](./../../public/assets/os/c83a68d2e2f440cc9e544f9d46f2d660.webp)

#### 2.4.3 死锁避免

![](./../../public/assets/os/58f3f31600e94c8496d50dc739529132.webp)

![](./../../public/assets/os/86dafe823fa542d49592ccc16ca09d58.webp) ![](./../../public/assets/os/10c48293b25347978d5bc8ce80085f02.webp) ![](./../../public/assets/os/5369bb23cf744296a14401567b1bbbab.webp) ![](./../../public/assets/os/5626979ae50e488cb3a3aa5c260e88ab.webp)

#### 2.4.4 死锁检测和解除

+   死锁检测  
    
    ![](./../../public/assets/os/ffe92fc7c040475b8bd6043b1c0cc339.webp) ![](./../../public/assets/os/d12b26b3bf6b4e25bcadee4b228ecfcb.webp)
+   死锁解除  
    
    ![](./../../public/assets/os/477bb72b2ebf4e6f8038ae2616f98b95.webp)

#### 2.4.5 本节小结

1 ）为什么会产生死锁 ？产生死锁有什么条件 ？

由于系统中存在一些不可剥夺资源 ，当两个或两个以上的进程占有自身的资源并请求对方的资源时 ，会导致每个进程都无法向前推进 ，这就是死锁。死锁产生的必要条件有4个 ，分别是互条件、不剥夺条件、请求并保持条件和循环等待条件 
互斥条件是指进程要求分配的资源是排他性的 ，即最多只能同时供一个进程使用。 
不剥夺条件是指进程在使用完资源之前 ，资源不能被强制夺走。 
请求并保持条件是指进程占有自身本来拥有的资源并要求其他资源 
循环等待条件是指存在一种进程资源的循环等待链。

2 ）有什么办法可以解决死锁问题 ？

死锁的处理策略可以分为预防死锁、避免死锁及死锁的检测与解除

+   死锁预防是指通过设立一些限制条件 ，破坏死锁的一些必要条件 ，让死锁无法发生。
+   死锁避免指在动态分配资源的过程中 ，用一些算法防止系统进入不安全状态 ，从而避免死锁。
+   死锁的检测和解除是指在死锁产生前不采取任何措施 ，只检测当前系统有没有发生死锁 ，若有 ，则采取一些措施解除死锁。

### 2.5 本章疑难点

#### 1 进程与程序的区别与联系

> 1 ）进程是程序及其数据在计算机上的一次运行活动 ，是一个动态的概念。进程的运行实体是程序 ，离开程序的进程没有存在的意义。从静态角度看 ，进程是由程序、数据和进程控制块 （PCB ）三部分组成的。而程序是一组有序的指令集合 ，是一种静态的概念。
>
> 2 ）进程是程序的一次执行过程 ，它是动态地创建和消亡的 ，具有一定的生命周期 ，是暂时存在的 ：而程序则是一组代码的集合 ，是永久存在的 ，可长期保存。 
> 3 ）一个进程可以执行一个或几个程序 ，一个程序也可构成多个进程。进程可创建进程 ，而程序不可能形成新的程序。 
> 4 ）进程与程序的组成不同。进程的组成包括程序、数据和PCB

#### 2 银行家算法的工作原理

> 银行家算法的主要思想是避免系统进入不安全状态。在每次进行资源分配时 ，它首先检查系统是否有足够的资源满足要求 ，若有则先进行试分配 ，并对分配后的新状态进行安全性检查。若新状态安全 ，则正式分配上述资源 ，否则拒绝分配上述资源。这样 ，它保证系统始终处于安全状态 ，从而避免了死锁现象的发生。

#### 3 进程同步、互斥的区别和联系

> 并发进程的执行会产生相互制约的关系 ：一种是进程之间竞争使用临界资源 ，只能让它们逐个使用 ，这种现象称为互斤 ，是一种竞争关系 ：另一种是进程之间协同完成任务 ，在关键点上等待另一个进程发来的消息 ，以便协同一致 ，是一种协作关系。
